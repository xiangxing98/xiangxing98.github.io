
<!-- saved from url=(0077)http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html -->
<html slick-uniqueid="3"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>9 Git 内部原理 - Pro Git</title>
    
    <link href="./9.Git_Internal_Mechanical_Pro_Git_files/styles.css" media="screen" rel="stylesheet" type="text/css">
    <link href="./9.Git_Internal_Mechanical_Pro_Git_files/prettify.css" rel="stylesheet" type="text/css">
    <script src="./9.Git_Internal_Mechanical_Pro_Git_files/prettify.js.下载" type="text/javascript"></script>
    <script src="./9.Git_Internal_Mechanical_Pro_Git_files/jquery-1.8.3.min.js.下载" type="text/javascript"></script>
    <script src="./9.Git_Internal_Mechanical_Pro_Git_files/book.js.下载" type="text/javascript"></script>
</head>
<body youdao="bind">
<div id="book-chapters">
<a class="right-home" href="http://git.oschina.net/" style="margin-left: 20px;">返回 码云</a>
<a class="right-home" href="http://git.oschina.net/progit/index.html">首页(目录)</a>
<a class="dropdown-trigger" id="book-chapters-trigger" data-panel-id="chapters-dropdown" href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#">章节列表 ▾</a>
Pro Git（中文版）
<div class="dropdown-panel" id="chapters-dropdown">
<div class="three-column">
<div class="column-left">
    <ol class="book-toc">
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/1-%E8%B5%B7%E6%AD%A5.html">1.起步</a></h2>
            <ol class="chapter_toc">
                <li>
                    <a href="http://git.oschina.net/progit/1-%E8%B5%B7%E6%AD%A5.html#1.1-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">1.1
                        关于版本控制</a></li>
                <li><a href="http://git.oschina.net/progit/1-%E8%B5%B7%E6%AD%A5.html#1.2-Git-%E7%AE%80%E5%8F%B2">1.2 Git 简史</a></li>
                <li><a href="http://git.oschina.net/progit/1-%E8%B5%B7%E6%AD%A5.html#1.3-Git-%E5%9F%BA%E7%A1%80">1.3 Git 基础</a></li>
                <li><a href="http://git.oschina.net/progit/1-%E8%B5%B7%E6%AD%A5.html#1.4-%E5%AE%89%E8%A3%85-Git">1.4 安装 Git</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/1-%E8%B5%B7%E6%AD%A5.html#1.5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE">1.5
                        初次运行 Git 前的配置</a></li>
                <li><a href="http://git.oschina.net/progit/1-%E8%B5%B7%E6%AD%A5.html#1.6-%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9">1.6
                    获取帮助</a></li>
                <li><a href="http://git.oschina.net/progit/1-%E8%B5%B7%E6%AD%A5.html#1.7-%E5%B0%8F%E7%BB%93">1.7 小结</a></li>
            </ol>
        </li>
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html">2.Git 基础</a></h2>
            <ol class="chapter_toc">
                <li>
                    <a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html#2.1-%E5%8F%96%E5%BE%97%E9%A1%B9%E7%9B%AE%E7%9A%84-Git-%E4%BB%93%E5%BA%93">2.1
                        取得项目的 Git 仓库</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html#2.2-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93">2.2
                        记录每次更新到仓库</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html#2.3-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">2.3
                        查看提交历史</a></li>
                <li><a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html#2.4-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C">2.4
                    撤消操作</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html#2.5-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8">2.5
                        远程仓库的使用</a></li>
                <li><a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html#2.6-%E6%89%93%E6%A0%87%E7%AD%BE">2.6 打标签</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html#2.7-%E6%8A%80%E5%B7%A7%E5%92%8C%E7%AA%8D%E9%97%A8">2.7
                        技巧和窍门</a></li>
                <li><a href="http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html#2.8-%E5%B0%8F%E7%BB%93">2.8 小结</a></li>
            </ol>
        </li>
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html">3.Git 分支</a></h2>
            <ol class="chapter_toc">
                <li><a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.1-%E4%BD%95%E8%B0%93%E5%88%86%E6%94%AF">3.1
                    何谓分支</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.2-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">3.2
                        分支的新建与合并</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.3-%E5%88%86%E6%94%AF%E7%9A%84%E7%AE%A1%E7%90%86">3.3
                        分支的管理</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.4-%E5%88%A9%E7%94%A8%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">3.4
                        利用分支进行开发的工作流程</a></li>
                <li><a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.5-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">3.5
                    远程分支</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.6-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88">3.6
                        分支的衍合</a></li>
                <li><a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.7-%E5%B0%8F%E7%BB%93">3.7 小结</a></li>
            </ol>
        </li>
    </ol>
</div>
<div class="column-middle">
    <ol class="book-toc">
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html">4.服务器上的 Git</a></h2>
            <ol class="chapter_toc">
                <li>
                    <a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.1-%E5%8D%8F%E8%AE%AE">4.1
                        协议</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.2-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2-Git">4.2
                        在服务器上部署 Git</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.3-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5">4.3
                        生成 SSH 公钥</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.4-%E6%9E%B6%E8%AE%BE%E6%9C%8D%E5%8A%A1%E5%99%A8">4.4
                        架设服务器</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.5-%E5%85%AC%E5%85%B1%E8%AE%BF%E9%97%AE">4.5
                        公共访问</a></li>
                <li><a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.6-GitWeb">4.6
                    GitWeb</a></li>
                <li><a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.7-Gitosis">4.7
                    Gitosis</a></li>
                <li><a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.8-Gitolite">4.8
                    Gitolite</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.9-Git-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">4.9
                        Git 守护进程</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.10-Git-%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1">4.10
                        Git 托管服务</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#4.11-%E5%B0%8F%E7%BB%93">4.11
                        小结</a></li>
            </ol>
        </li>
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/5-%E5%88%86%E5%B8%83%E5%BC%8F-Git.html">5.分布式 Git</a></h2>
            <ol class="chapter_toc">
                <li>
                    <a href="http://git.oschina.net/progit/5-%E5%88%86%E5%B8%83%E5%BC%8F-Git.html#5.1-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">5.1
                        分布式工作流程</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/5-%E5%88%86%E5%B8%83%E5%BC%8F-Git.html#5.2-%E4%B8%BA%E9%A1%B9%E7%9B%AE%E4%BD%9C%E8%B4%A1%E7%8C%AE">5.2
                        为项目作贡献</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/5-%E5%88%86%E5%B8%83%E5%BC%8F-Git.html#5.3-%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AE%A1%E7%90%86">5.3
                        项目的管理</a></li>
                <li><a href="http://git.oschina.net/progit/5-%E5%88%86%E5%B8%83%E5%BC%8F-Git.html#5.4-%E5%B0%8F%E7%BB%93">5.4 小结</a></li>
            </ol>
        </li>
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html">6.Git 工具</a></h2>
            <ol class="chapter_toc">
                <li>
                    <a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html#6.1-%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC%EF%BC%88Revision%EF%BC%89%E9%80%89%E6%8B%A9">6.1
                        修订版本（Revision）选择</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html#6.2-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98">6.2
                        交互式暂存</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html#6.3-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89">6.3
                        储藏（Stashing）</a></li>
                <li><a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html#6.4-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2">6.4
                    重写历史</a></li>
                <li><a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html#6.5-%E4%BD%BF%E7%94%A8-Git-%E8%B0%83%E8%AF%95">6.5
                    使用 Git 调试</a></li>
                <li><a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html#6.6-%E5%AD%90%E6%A8%A1%E5%9D%97">6.6 子模块</a></li>
                <li><a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html#6.7-%E5%AD%90%E6%A0%91%E5%90%88%E5%B9%B6">6.7
                    子树合并</a></li>
                <li><a href="http://git.oschina.net/progit/6-Git-%E5%B7%A5%E5%85%B7.html#6.8-%E6%80%BB%E7%BB%93">6.8 总结</a></li>
            </ol>
        </li>
    </ol>
</div>
<div class="column-right">
    <ol class="book-toc">
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/7-%E8%87%AA%E5%AE%9A%E4%B9%89-Git.html">7.自定义 Git</a></h2>
            <ol class="chapter_toc">
                <li><a href="http://git.oschina.net/progit/7-%E8%87%AA%E5%AE%9A%E4%B9%89-Git.html#7.1-%E9%85%8D%E7%BD%AE-Git">7.1 配置
                    Git</a></li>
                <li><a href="http://git.oschina.net/progit/7-%E8%87%AA%E5%AE%9A%E4%B9%89-Git.html#7.2-Git%E5%B1%9E%E6%80%A7">7.2 Git属性</a>
                </li>
                <li><a href="http://git.oschina.net/progit/7-%E8%87%AA%E5%AE%9A%E4%B9%89-Git.html#7.3-Git%E6%8C%82%E9%92%A9">7.3 Git挂钩</a>
                </li>
                <li>
                    <a href="http://git.oschina.net/progit/7-%E8%87%AA%E5%AE%9A%E4%B9%89-Git.html#7.4-Git-%E5%BC%BA%E5%88%B6%E7%AD%96%E7%95%A5%E5%AE%9E%E4%BE%8B">7.4
                        Git 强制策略实例</a></li>
                <li><a href="http://git.oschina.net/progit/7-%E8%87%AA%E5%AE%9A%E4%B9%89-Git.html#7.5-%E6%80%BB%E7%BB%93">7.5 总结</a></li>
            </ol>
        </li>
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/8-Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F.html">8.Git 与其他系统</a></h2>
            <ol class="chapter_toc">
                <li>
                    <a href="http://git.oschina.net/progit/8-Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F.html#8.1-Git-%E4%B8%8E-Subversion">8.1
                        Git 与 Subversion</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/8-Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F.html#8.2-%E8%BF%81%E7%A7%BB%E5%88%B0-Git">8.2
                        迁移到 Git</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/8-Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F.html#8.3-%E6%80%BB%E7%BB%93">8.3
                        总结</a></li>
            </ol>
        </li>
        <li class="chapter">
            <h2><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html">9.Git 内部原理</a></h2>
            <ol class="chapter_toc">
                <li>
                    <a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4-(Plumbing)-%E5%92%8C%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4-(Porcelain)">9.1
                        底层命令 (Plumbing) 和高层命令 (Porcelain)</a></li>
                <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.2-Git-%E5%AF%B9%E8%B1%A1">9.2
                    Git 对象</a></li>
                <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.3-Git-References">9.3 Git
                    References</a></li>
                <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.4-Packfiles">9.4
                    Packfiles</a></li>
                <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.5-The-Refspec">9.5 The
                    Refspec</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.6-%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">9.6
                        传输协议</a></li>
                <li>
                    <a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.7-%E7%BB%B4%E6%8A%A4%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D">9.7
                        维护及数据恢复</a></li>
                <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.8-%E6%80%BB%E7%BB%93">9.8
                    总结</a></li>
            </ol>
        </li>
    </ol>
</div>
</div>
</div>
</div>
<h1>9 Git 内部原理</h1>
<ol class="chapter_toc">
    <li>
        <a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4-(Plumbing)-%E5%92%8C%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4-(Porcelain)">底层命令
            (Plumbing) 和高层命令 (Porcelain)</a></li>
    <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.2-Git-%E5%AF%B9%E8%B1%A1">9.2 Git 对象</a></li>
    <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.3-Git-References">9.3 Git References</a></li>
    <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.4-Packfiles">9.4 Packfiles</a></li>
    <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.5-The-Refspec">9.5 The Refspec</a></li>
    <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.6-%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">9.6 传输协议</a></li>
    <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.7-%E7%BB%B4%E6%8A%A4%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D">9.7 维护及数据恢复</a></li>
    <li><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.8-%E6%80%BB%E7%BB%93">9.8 总结</a></li>
</ol>

<p>不管你是从前面的章节直接跳到了本章，还是读完了其余各章一直到这，你都将在本章见识 Git 的内部工作原理和实现方式。我个人发现学习这些内容对于理解 Git
    的用处和强大是非常重要的，不过也有人认为这些内容对于初学者来说可能难以理解且过于复杂。正因如此我把这部分内容放在最后一章，你在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这完全取决于你自己。</p>

<p>既然已经读到这了，就让我们开始吧。首先要弄明白一点，从根本上来讲 Git 是一套内容寻址 (content-addressable) 文件系统，在此之上提供了一个 VCS 用户界面。马上你就会学到这意味着什么。</p>

<p>早期的 Git (主要是 1.5 之前版本) 的用户界面要比现在复杂得多，这是因为它更侧重于成为文件系统而不是一套更精致的 VCS 。最近几年改进了 UI 从而使它跟其他任何系统一样清晰易用。即便如此，还是经常会有一些陈腔滥调提到早期
    Git 的 UI 复杂又难学。</p>

<p>内容寻址文件系统层相当酷，在本章中我会先讲解这部分。随后你会学到传输机制和最终要使用的各种库管理任务。</p>

<h2>
    <a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4-(Plumbing)-%E5%92%8C%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4-(Porcelain)">9.1
        底层命令 (Plumbing) 和高层命令 (Porcelain)</a></h2>

<p>本书讲解了使用 <code>checkout</code>, <code>branch</code>, <code>remote</code> 等共约 30 个 Git 命令。然而由于 Git 一开始被设计成供 VCS
    使用的工具集而不是一整套用户友好的 VCS，它还包含了许多底层命令，这些命令用于以 UNIX 风格使用或由脚本调用。这些命令一般被称为 "plumbing" 命令（底层命令），其他的更友好的命令则被称为
    "porcelain" 命令（高层命令）。</p>

<p>本书前八章主要专门讨论高层命令。本章将主要讨论底层命令以理解 Git 的内部工作机制、演示 Git 如何及为何要以这种方式工作。这些命令主要不是用来从命令行手工使用的，更多的是用来为其他工具和自定义脚本服务的。</p>

<p>当你在一个新目录或已有目录内执行 <code>git init</code> 时，Git 会创建一个 <code>.git</code> 目录，几乎所有 Git
    存储和操作的内容都位于该目录下。如果你要备份或复制一个库，基本上将这一目录拷贝至其他地方就可以了。本章基本上都讨论该目录下的内容。该目录结构如下：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ ls
    HEAD
    branches</span><span class="pun">/</span><span class="pln">
    config
    description
    hooks</span><span class="pun">/</span><span class="pln">
    index
    info</span><span class="pun">/</span><span class="pln">
    objects</span><span class="pun">/</span><span class="pln">
    refs</span><span class="pun">/</span></code></pre>

<p>该目录下有可能还有其他文件，但这是一个全新的 <code>git init</code> 生成的库，所以默认情况下这些就是你能看到的结构。新版本的 Git 不再使用 <code>branches</code> 目录，<code>description</code>
    文件仅供 GitWeb 程序使用，所以不用关心这些内容。<code>config</code> 文件包含了项目特有的配置选项，<code>info</code> 目录保存了一份不希望在 .gitignore 文件中管理的忽略模式
    (ignored patterns) 的全局可执行文件。<code>hooks</code> 目录保存了第七章详细介绍了的客户端或服务端钩子脚本。</p>

<p>另外还有四个重要的文件或目录：<code>HEAD</code> 及 <code>index</code> 文件，<code>objects</code> 及 <code>refs</code> 目录。这些是 Git
    的核心部分。<code>objects</code> 目录存储所有数据内容，<code>refs</code> 目录存储指向数据 (分支) 的提交对象的指针，<code>HEAD</code> 文件指向当前分支，<code>index</code>
    文件保存了暂存区域信息。马上你将详细了解 Git 是如何操纵这些内容的。</p>

<h2 id="9.2-Git-对象"><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.2-Git-%E5%AF%B9%E8%B1%A1">9.2 Git 对象</a></h2>

<p>Git 是一套内容寻址文件系统。很不错。不过这是什么意思呢？
    这种说法的意思是，Git 从核心上来看不过是简单地存储键值对（key-value）。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。可以通过底层命令 <code>hash-object</code>
    来示范这点，传一些数据给该命令，它会将数据保存在 <code>.git</code> 目录并返回表示这些数据的键值。首先初使化一个 Git 仓库并确认 <code>objects</code> 目录是空的：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ mkdir test
    $ cd test
    $ git init
    </span><span class="typ">Initialized</span><span class="pln"> empty </span><span class="typ">Git</span><span class="pln"> repository </span><span class="kwd">in</span><span class="pln"> </span><span class="pun">/</span><span class="pln">tmp</span><span class="pun">/</span><span class="pln">test</span><span class="pun">/.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">
    $ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">info
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">pack
    $ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects </span><span class="pun">-</span><span class="pln">type f
    $</span></code></pre>

<p>Git 初始化了 <code>objects</code> 目录，同时在该目录下创建了 <code>pack</code> 和 <code>info</code> 子目录，但是该目录下没有其他常规文件。我们往这个 Git
    数据库里存储一些文本：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ echo </span><span class="str">'test content'</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> git hash</span><span class="pun">-</span><span class="kwd">object</span><span class="pln"> </span><span class="pun">-</span><span class="pln">w </span><span class="pun">--</span><span class="pln">stdin
    d670460b4b4aece5915caf5c68d12f560a9fe3e4</span></code></pre>

<p>参数 <code>-w</code> 指示 <code>hash-object</code> 命令存储 (数据) 对象，若不指定这个参数该命令仅仅返回键值。<code>--stdin</code> 指定从标准输入设备 (stdin)
    来读取内容，若不指定这个参数则需指定一个要存储的文件的路径。该命令输出长度为 40 个字符的校验和。这是个 SHA-1 哈希值──其值为要存储的数据加上你马上会了解到的一种头信息的校验和。现在可以查看到 Git 已经存储了数据：
</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects </span><span class="pun">-</span><span class="pln">type f
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">d6</span><span class="pun">/</span><span class="lit">70460b4b4aece5915caf5c68d12f560a9fe3e4</span></code></pre>

<p>可以在 <code>objects</code> 目录下看到一个文件。这便是 Git 存储数据内容的方式──为每份内容生成一个文件，取得该内容与头信息的 SHA-1 校验和，创建以该校验和前两个字符为名称的子目录，并以 (校验和)
    剩下 38 个字符为文件命名 (保存至子目录下)。</p>

<p>通过 <code>cat-file</code> 命令可以将数据内容取回。该命令是查看 Git 对象的瑞士军刀。传入 <code>-p</code> 参数可以让该命令输出数据内容的类型：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p d670460b4b4aece5915caf5c68d12f560a9fe3e4
    test content</span></code></pre>

<p>可以往 Git 中添加更多内容并取回了。也可以直接添加文件。比方说可以对一个文件进行简单的版本控制。首先，创建一个新文件，并把文件内容存储到数据库中：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ echo </span><span class="str">'version 1'</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">txt
    $ git hash</span><span class="pun">-</span><span class="kwd">object</span><span class="pln"> </span><span class="pun">-</span><span class="pln">w test</span><span class="pun">.</span><span class="pln">txt
    </span><span class="lit">83baae61804e65cc73a7201a7252750c76066a30</span></code></pre>

<p>接着往该文件中写入一些新内容并再次保存：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ echo </span><span class="str">'version 2'</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">txt
    $ git hash</span><span class="pun">-</span><span class="kwd">object</span><span class="pln"> </span><span class="pun">-</span><span class="pln">w test</span><span class="pun">.</span><span class="pln">txt
    </span><span class="lit">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span></code></pre>

<p>数据库中已经将文件的两个新版本连同一开始的内容保存下来了：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects </span><span class="pun">-</span><span class="pln">type f
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">1f</span><span class="pun">/</span><span class="lit">7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">83</span><span class="pun">/</span><span class="pln">baae61804e65cc73a7201a7252750c76066a30
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">d6</span><span class="pun">/</span><span class="lit">70460b4b4aece5915caf5c68d12f560a9fe3e4</span></code></pre>

<p>再将文件恢复到第一个版本：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p </span><span class="lit">83baae61804e65cc73a7201a7252750c76066a30</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">txt
    $ cat test</span><span class="pun">.</span><span class="pln">txt
    version </span><span class="lit">1</span></code></pre>

<p>或恢复到第二个版本：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p </span><span class="lit">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">txt
    $ cat test</span><span class="pun">.</span><span class="pln">txt
    version </span><span class="lit">2</span></code></pre>

<p>需要记住的是几个版本的文件 SHA-1 值可能与实际的值不同，其次，存储的并不是文件名而仅仅是文件内容。这种对象类型称为 blob 。通过传递 SHA-1 值给 <code>cat-file -t</code> 命令可以让 Git
    返回任何对象的类型：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">t </span><span class="lit">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><span class="pln">
    blob</span></code></pre>

<h3>tree (树) 对象</h3>

<p>接下去来看 tree 对象，tree 对象可以存储文件名，同时也允许存储一组文件。Git 以一种类似 UNIX 文件系统但更简单的方式来存储内容。所有内容以 tree 或 blob 对象存储，其中 tree 对象对应于 UNIX
    中的目录，blob 对象则大致对应于 inodes 或文件内容。一个单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 或子 tree 对象的 SHA-1 指针，并附有该对象的权限模式
    (mode)、类型和文件名信息。以 simplegit 项目为例，最新的 tree 可能是这个样子：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p master</span><span class="pun">^{</span><span class="pln">tree</span><span class="pun">}</span><span class="pln">
    </span><span class="lit">100644</span><span class="pln"> blob a906cb2a4a904a152e80877d4088654daad0c859 README
    </span><span class="lit">100644</span><span class="pln"> blob </span><span class="lit">8f94139338f9404f26296befa88755fc2598c289</span><span class="pln"> </span><span class="typ">Rakefile</span><span class="pln">
    </span><span class="lit">040000</span><span class="pln"> tree </span><span class="lit">99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><span class="pln"> lib</span></code></pre>

<p><code>master^{tree}</code> 表示 <code>branch</code> 分支上最新提交指向的 tree 对象。请注意 <code>lib</code> 子目录并非一个 blob 对象，而是一个指向别一个
    tree 对象的指针：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p </span><span class="lit">99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><span class="pln">
    </span><span class="lit">100644</span><span class="pln"> blob </span><span class="lit">47c6340d6459e05787f644c2447d2595f5d3a54b</span><span class="pln"> simplegit</span><span class="pun">.</span><span class="pln">rb</span></code></pre>

<p>从概念上来讲，Git 保存的数据如图 9-1 所示。</p>

<p>
</p><center><img src="./9.Git_Internal_Mechanical_Pro_Git_files/18333fig0901-tn.png"></center>
<br>
图 9-1. Git 对象模型的简化版<p></p>

<p>你可以自己创建 tree 。通常 Git 根据你的暂存区域或 index 来创建并写入一个 tree 。因此要创建一个 tree 对象的话首先要通过将一些文件暂存从而创建一个 index 。可以使用 plumbing 命令
    <code>update-index</code> 为一个单独文件 ── test.txt 文件的第一个版本 ──　创建一个 index　。通过该命令人为的将 test.txt
    文件的首个版本加入到了一个新的暂存区域中。由于该文件原先并不在暂存区域中 (甚至就连暂存区域也还没被创建出来呢) ，必须传入 <code>--add</code> 参数;由于要添加的文件并不在当前目录下而是在数据库中，必须传入
    <code>--cacheinfo</code> 参数。同时指定了文件模式，SHA-1 值和文件名：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git update</span><span class="pun">-</span><span class="pln">index </span><span class="pun">--</span><span class="pln">add </span><span class="pun">--</span><span class="pln">cacheinfo </span><span class="lit">100644</span><span class="pln"> \
    </span><span class="lit">83baae61804e65cc73a7201a7252750c76066a30</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">txt</span></code></pre>

<p>在本例中，指定了文件模式为 <code>100644</code>，表明这是一个普通文件。其他可用的模式有：<code>100755</code> 表示可执行文件，<code>120000</code>
    表示符号链接。文件模式是从常规的 UNIX 文件模式中参考来的，但是没有那么灵活 ── 上述三种模式仅对 Git 中的文件 (blobs) 有效 (虽然也有其他模式用于目录和子模块)。</p>

<p>现在可以用 <code>write-tree</code> 命令将暂存区域的内容写到一个 tree 对象了。无需 <code>-w</code> 参数 ── 如果目标 tree 不存在，调用
    <code>write-tree</code> 会自动根据 index 状态创建一个 tree 对象。</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git write</span><span class="pun">-</span><span class="pln">tree
    d8329fc1cc938780ffdd9f94e0d364e0ea74f579
    $ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
    </span><span class="lit">100644</span><span class="pln"> blob </span><span class="lit">83baae61804e65cc73a7201a7252750c76066a30</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">txt</span></code></pre>

<p>可以这样验证这确实是一个 tree 对象：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
    tree</span></code></pre>

<p>再根据 test.txt 的第二个版本以及一个新文件创建一个新 tree 对象：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ echo </span><span class="str">'new file'</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">new</span><span class="pun">.</span><span class="pln">txt
    $ git update</span><span class="pun">-</span><span class="pln">index test</span><span class="pun">.</span><span class="pln">txt
    $ git update</span><span class="pun">-</span><span class="pln">index </span><span class="pun">--</span><span class="pln">add </span><span class="kwd">new</span><span class="pun">.</span><span class="pln">txt</span></code></pre>

<p>这时暂存区域中包含了 test.txt 的新版本及一个新文件 new.txt 。创建 (写) 该 tree 对象 (将暂存区域或 index 状态写入到一个 tree 对象)，然后瞧瞧它的样子：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git write</span><span class="pun">-</span><span class="pln">tree
    </span><span class="lit">0155eb4229851634a0f03eb265b69f5a2d56f341</span><span class="pln">
    $ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p </span><span class="lit">0155eb4229851634a0f03eb265b69f5a2d56f341</span><span class="pln">
    </span><span class="lit">100644</span><span class="pln"> blob fa49b077972391ad58037050f2a75f74e3671e92 </span><span class="kwd">new</span><span class="pun">.</span><span class="pln">txt
    </span><span class="lit">100644</span><span class="pln"> blob </span><span class="lit">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">txt</span></code></pre>

<p>请注意该 tree 对象包含了两个文件记录，且 test.txt 的 SHA 值是早先值的 "第二版" (<code>1f7a7a</code>)。来点更有趣的，你将把第一个 tree 对象作为一个子目录加进该
    tree 中。可以用 <code>read-tree</code> 命令将 tree 对象读到暂存区域中去。在这时，通过传一个 <code>--prefix</code> 参数给 <code>read-tree</code>，将一个已有的
    tree 对象作为一个子 tree 读到暂存区域中：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git read</span><span class="pun">-</span><span class="pln">tree </span><span class="pun">--</span><span class="pln">prefix</span><span class="pun">=</span><span class="pln">bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
    $ git write</span><span class="pun">-</span><span class="pln">tree
    </span><span class="lit">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><span class="pln">
    $ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p </span><span class="lit">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><span class="pln">
    </span><span class="lit">040000</span><span class="pln"> tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 bak
    </span><span class="lit">100644</span><span class="pln"> blob fa49b077972391ad58037050f2a75f74e3671e92 </span><span class="kwd">new</span><span class="pun">.</span><span class="pln">txt
    </span><span class="lit">100644</span><span class="pln"> blob </span><span class="lit">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">txt</span></code></pre>

<p>如果从刚写入的新 tree 对象创建一个工作目录，将得到位于工作目录顶级的两个文件和一个名为 <code>bak</code> 的子目录，该子目录包含了 test.txt 文件的第一个版本。可以将 Git
    用来包含这些内容的数据想象成如图 9-2 所示的样子。</p>

<p>
</p><center><img src="./9.Git_Internal_Mechanical_Pro_Git_files/18333fig0902-tn.png"></center>
<br>
图 9-2. 当前 Git 数据的内容结构<p></p>

<h3>commit (提交) 对象</h3>

<p>你现在有三个 tree 对象，它们指向了你要跟踪的项目的不同快照，可是先前的问题依然存在：必须记往三个 SHA-1 值以获得这些快照。你也没有关于谁、何时以及为何保存了这些快照的信息。commit 对象为你保存了这些基本信息。</p>

<p>要创建一个 commit 对象，使用 <code>commit-tree</code> 命令，指定一个 tree 的 SHA-1，如果有任何前继提交对象，也可以指定。从你写的第一个 tree 开始：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ echo </span><span class="str">'first commit'</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> git commit</span><span class="pun">-</span><span class="pln">tree d8329f
    fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span></code></pre>

<p>通过 <code>cat-file</code> 查看这个新 commit 对象：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p fdf4fc3
    tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
    author </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">1243040974</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">
    committer </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">1243040974</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">

    first commit</span></code></pre>

<p>commit 对象有格式很简单：指明了该时间点项目快照的顶层树对象、作者/提交者信息（从 Git 设置的 <code>user.name</code> 和 <code>user.email</code>中获得)以及当前时间戳、一个空行，以及提交注释信息。
</p>

<p>接着再写入另外两个 commit 对象，每一个都指定其之前的那个 commit 对象：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ echo </span><span class="str">'second commit'</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> git commit</span><span class="pun">-</span><span class="pln">tree </span><span class="lit">0155eb</span><span class="pln"> </span><span class="pun">-</span><span class="pln">p fdf4fc3
    cac0cab538b970a37ea1e769cbbde608743bc96d
    $ echo </span><span class="str">'third commit'</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> git commit</span><span class="pun">-</span><span class="pln">tree </span><span class="lit">3c4e9c</span><span class="pln"> </span><span class="pun">-</span><span class="pln">p cac0cab
    </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span></code></pre>

<p>每一个 commit 对象都指向了你创建的树对象快照。出乎意料的是，现在已经有了真实的 Git 历史了，所以如果运行 <code>git log</code> 命令并指定最后那个 commit 对象的 SHA-1 便可以查看历史：
</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git log </span><span class="pun">--</span><span class="pln">stat </span><span class="lit">1a410e</span><span class="pln">
    commit </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln">
    </span><span class="typ">Author</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="typ">Date</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Fri</span><span class="pln"> </span><span class="typ">May</span><span class="pln"> </span><span class="lit">22</span><span class="pln"> </span><span class="lit">18</span><span class="pun">:</span><span class="lit">15</span><span class="pun">:</span><span class="lit">24</span><span class="pln"> </span><span class="lit">2009</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">

    third commit

    bak</span><span class="pun">/</span><span class="pln">test</span><span class="pun">.</span><span class="pln">txt </span><span class="pun">|</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln">
    </span><span class="lit">1</span><span class="pln"> files changed</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> insertions</span><span class="pun">(+),</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> deletions</span><span class="pun">(-)</span><span class="pln">

    commit cac0cab538b970a37ea1e769cbbde608743bc96d
    </span><span class="typ">Author</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="typ">Date</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Fri</span><span class="pln"> </span><span class="typ">May</span><span class="pln"> </span><span class="lit">22</span><span class="pln"> </span><span class="lit">18</span><span class="pun">:</span><span class="lit">14</span><span class="pun">:</span><span class="lit">29</span><span class="pln"> </span><span class="lit">2009</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">

    second commit

    </span><span class="kwd">new</span><span class="pun">.</span><span class="pln">txt </span><span class="pun">|</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln">
    test</span><span class="pun">.</span><span class="pln">txt </span><span class="pun">|</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">+-</span><span class="pln">
    </span><span class="lit">2</span><span class="pln"> files changed</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> insertions</span><span class="pun">(+),</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> deletions</span><span class="pun">(-)</span><span class="pln">

    commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
    </span><span class="typ">Author</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="typ">Date</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Fri</span><span class="pln"> </span><span class="typ">May</span><span class="pln"> </span><span class="lit">22</span><span class="pln"> </span><span class="lit">18</span><span class="pun">:</span><span class="lit">09</span><span class="pun">:</span><span class="lit">34</span><span class="pln"> </span><span class="lit">2009</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">

    first commit

    test</span><span class="pun">.</span><span class="pln">txt </span><span class="pun">|</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln">
    </span><span class="lit">1</span><span class="pln"> files changed</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> insertions</span><span class="pun">(+),</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> deletions</span><span class="pun">(-)</span></code></pre>

<p>真棒。你刚刚通过使用低级操作而不是那些普通命令创建了一个 Git 历史。这基本上就是运行　<code>git add</code> 和 <code>git commit</code> 命令时 Git 进行的工作　──保存修改了的文件的
    blob，更新索引，创建 tree 对象，最后创建 commit 对象，这些 commit 对象指向了顶层 tree 对象以及先前的 commit 对象。这三类 Git 对象 ── blob，tree 以及 tree ──
    都各自以文件的方式保存在 <code>.git/objects</code> 目录下。以下所列是目前为止样例中的所有对象，每个对象后面的注释里标明了它们保存的内容：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects </span><span class="pun">-</span><span class="pln">type f
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">01</span><span class="pun">/</span><span class="lit">55eb4229851634a0f03eb265b69f5a2d56f341</span><span class="pln"> </span><span class="com"># tree 2</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">1a</span><span class="pun">/</span><span class="lit">410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln"> </span><span class="com"># commit 3</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">1f</span><span class="pun">/</span><span class="lit">7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><span class="pln"> </span><span class="com"># test.txt v2</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">3c</span><span class="pun">/</span><span class="lit">4e9cd789d88d8d89c1073707c3585e41b0e614</span><span class="pln"> </span><span class="com"># tree 3</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">83</span><span class="pun">/</span><span class="pln">baae61804e65cc73a7201a7252750c76066a30 </span><span class="com"># test.txt v1</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">ca</span><span class="pun">/</span><span class="pln">c0cab538b970a37ea1e769cbbde608743bc96d </span><span class="com"># commit 2</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">d6</span><span class="pun">/</span><span class="lit">70460b4b4aece5915caf5c68d12f560a9fe3e4</span><span class="pln"> </span><span class="com"># 'test content'</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">d8</span><span class="pun">/</span><span class="lit">329fc1cc938780ffdd9f94e0d364e0ea74f579</span><span class="pln"> </span><span class="com"># tree 1</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">fa</span><span class="pun">/</span><span class="lit">49b077972391ad58037050f2a75f74e3671e92</span><span class="pln"> </span><span class="com"># new.txt</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">fd</span><span class="pun">/</span><span class="pln">f4fc3344e67ab068f836878b6c4951e3b15f3d </span><span class="com"># commit 1</span></code></pre>

<p>如果你按照以上描述进行了操作，可以得到如图 9-3 所示的对象图。</p>

<p>
</p><center><img src="./9.Git_Internal_Mechanical_Pro_Git_files/18333fig0903-tn.png"></center>
<br>
图 9-3. Git 目录下的所有对象<p></p>

<h3>对象存储</h3>

<p>之前我提到当存储数据内容时，同时会有一个文件头被存储起来。我们花些时间来看看 Git 是如何存储对象的。你将看来如何通过 Ruby 脚本语言存储一个 blob 对象 (这里以字符串 "what is up, doc?"
    为例) 。使用 <code>irb</code> 命令进入 Ruby 交互式模式：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ irb
    </span><span class="pun">&gt;&gt;</span><span class="pln"> content </span><span class="pun">=</span><span class="pln"> </span><span class="str">"what is up, doc?"</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">"what is up, doc?"</span></code></pre>

<p>Git 以对象类型为起始内容构造一个文件头，本例中是一个 blob。然后添加一个空格，接着是数据内容的长度，最后是一个空字节 (null byte)：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">&gt;&gt;</span><span class="pln"> header </span><span class="pun">=</span><span class="pln"> </span><span class="str">"blob #{content.length}\0"</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">"blob 16\000"</span></code></pre>

<p>Git 将文件头与原始数据内容拼接起来，并计算拼接后的新内容的 SHA-1 校验和。可以在 Ruby 中使用 <code>require</code> 语句导入 SHA1 digest 库，然后调用 <code>Digest::SHA1.hexdigest()</code>
    方法计算字符串的 SHA-1 值：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">&gt;&gt;</span><span class="pln"> store </span><span class="pun">=</span><span class="pln"> header </span><span class="pun">+</span><span class="pln"> content
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">"blob 16\000what is up, doc?"</span><span class="pln">
    </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="kwd">require</span><span class="pln"> </span><span class="str">'digest/sha1'</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">true</span><span class="pln">
    </span><span class="pun">&gt;&gt;</span><span class="pln"> sha1 </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Digest</span><span class="pun">::</span><span class="pln">SHA1</span><span class="pun">.</span><span class="pln">hexdigest</span><span class="pun">(</span><span class="pln">store</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">"bd9dbf5aae1a3862dd1526723246b20206e5fc37"</span></code></pre>

<p>Git 用 zlib 对数据内容进行压缩，在 Ruby 中可以用 zlib 库来实现。首先需要导入该库，然后用 <code>Zlib::Deflate.deflate()</code> 对数据进行压缩：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="kwd">require</span><span class="pln"> </span><span class="str">'zlib'</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">true</span><span class="pln">
    </span><span class="pun">&gt;&gt;</span><span class="pln"> zlib_content </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Zlib</span><span class="pun">::</span><span class="typ">Deflate</span><span class="pun">.</span><span class="pln">deflate</span><span class="pun">(</span><span class="pln">store</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">"x\234K\312\311OR04c(\317H,Q\310,V(-\320QH\311O\266\a\000_\034\a\235"</span></code></pre>

<p>最后将用 zlib 压缩后的内容写入磁盘。需要指定保存对象的路径 (SHA-1 值的头两个字符作为子目录名称，剩余 38 个字符作为文件名保存至该子目录中)。在 Ruby 中，如果子目录不存在可以用 <code>FileUtils.mkdir_p()</code>
    函数创建它。接着用 <code>File.open</code> 方法打开文件，并用 <code>write()</code> 方法将之前压缩的内容写入该文件：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">&gt;&gt;</span><span class="pln"> path </span><span class="pun">=</span><span class="pln"> </span><span class="str">'.git/objects/'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> sha1</span><span class="pun">[</span><span class="lit">0</span><span class="pun">,</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">'/'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> sha1</span><span class="pun">[</span><span class="lit">2</span><span class="pun">,</span><span class="lit">38</span><span class="pun">]</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"</span><span class="pln">
    </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="kwd">require</span><span class="pln"> </span><span class="str">'fileutils'</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">true</span><span class="pln">
    </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">FileUtils</span><span class="pun">.</span><span class="pln">mkdir_p</span><span class="pun">(</span><span class="typ">File</span><span class="pun">.</span><span class="pln">dirname</span><span class="pun">(</span><span class="pln">path</span><span class="pun">))</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">".git/objects/bd"</span><span class="pln">
    </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">File</span><span class="pun">.</span><span class="pln">open</span><span class="pun">(</span><span class="pln">path</span><span class="pun">,</span><span class="pln"> </span><span class="str">'w'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="pun">|</span><span class="pln">f</span><span class="pun">|</span><span class="pln"> f</span><span class="pun">.</span><span class="pln">write zlib_content </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="lit">32</span></code></pre>

<p>这就行了 ── 你已经创建了一个正确的 blob 对象。所有的 Git 对象都以这种方式存储，惟一的区别是类型不同 ── 除了字符串 blob，文件头起始内容还可以是 commit 或 tree 。不过虽然 blob
    几乎可以是任意内容，commit 和 tree 的数据却是有固定格式的。</p>

<h2 id="9.3-Git-References"><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.3-Git-References">9.3 Git References</a></h2>

<p>你可以执行像 <code>git log 1a410e</code> 这样的命令来查看完整的历史，但是这样你就要记得 <code>1a410e</code>
    是你最后一次提交，这样才能在提交历史中找到这些对象。你需要一个文件来用一个简单的名字来记录这些 SHA-1 值，这样你就可以用这些指针而不是原来的 SHA-1 值去检索了。</p>

<p>在 Git 中，我们称之为“引用”（references 或者 refs，译者注）。你可以在 <code>.git/refs</code> 目录下面找到这些包含 SHA-1
    值的文件。在这个项目里，这个目录还没不包含任何文件，但是包含这样一个简单的结构：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">tags
    $ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs </span><span class="pun">-</span><span class="pln">type f
    $</span></code></pre>

<p>如果想要创建一个新的引用帮助你记住最后一次提交，技术上你可以这样做：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ echo </span><span class="str">"1a410efbd13591db07496601ebc7a059dd55cfe9"</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master</span></code></pre>

<p>现在，你就可以在 Git 命令中使用你刚才创建的引用而不是 SHA-1 值：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git log </span><span class="pun">--</span><span class="pln">pretty</span><span class="pun">=</span><span class="pln">oneline master
    </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln"> third commit
    cac0cab538b970a37ea1e769cbbde608743bc96d second commit
    fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span></code></pre>

<p>当然，我们并不鼓励你直接修改这些引用文件。如果你确实需要更新一个引用，Git 提供了一个安全的命令 <code>update-ref</code>：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git update</span><span class="pun">-</span><span class="kwd">ref</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span></code></pre>

<p>基本上 Git 中的一个分支其实就是一个指向某个工作版本一条 HEAD 记录的指针或引用。你可以用这条命令创建一个指向第二次提交的分支：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git update</span><span class="pun">-</span><span class="kwd">ref</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">test cac0ca</span></code></pre>

<p>这样你的分支将会只包含那次提交以及之前的工作：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git log </span><span class="pun">--</span><span class="pln">pretty</span><span class="pun">=</span><span class="pln">oneline test
    cac0cab538b970a37ea1e769cbbde608743bc96d second commit
    fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span></code></pre>

<p>现在，你的 Git 数据库应该看起来像图 9-4 一样。</p>

<p>
</p><center><img src="./9.Git_Internal_Mechanical_Pro_Git_files/18333fig0904-tn.png"></center>
<br>
图 9-4. 包含分支引用的 Git 目录对象<p></p>

<p>每当你执行 <code>git branch (分支名称)</code> 这样的命令，Git 基本上就是执行 <code>update-ref</code> 命令，把你现在所在分支中最后一次提交的 SHA-1
    值，添加到你要创建的分支的引用。</p>

<h3>HEAD 标记</h3>

<p>现在的问题是，当你执行 <code>git branch (分支名称)</code> 这条命令的时候，Git 怎么知道最后一次提交的 SHA-1 值呢？答案就是 HEAD 文件。HEAD
    文件是一个指向你当前所在分支的引用标识符。这样的引用标识符——它看起来并不像一个普通的引用——其实并不包含 SHA-1 值，而是一个指向另外一个引用的指针。如果你看一下这个文件，通常你将会看到这样的内容：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ cat </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">HEAD
    </span><span class="kwd">ref</span><span class="pun">:</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master</span></code></pre>

<p>如果你执行 <code>git checkout test</code>，Git 就会更新这个文件，看起来像这样：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ cat </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">HEAD
    </span><span class="kwd">ref</span><span class="pun">:</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">test</span></code></pre>

<p>当你再执行 <code>git commit</code> 命令，它就创建了一个 commit 对象，把这个 commit 对象的父级设置为 HEAD 指向的引用的 SHA-1 值。</p>

<p>你也可以手动编辑这个文件，但是同样有一个更安全的方法可以这样做：<code>symbolic-ref</code>。你可以用下面这条命令读取 HEAD 的值：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git symbolic</span><span class="pun">-</span><span class="kwd">ref</span><span class="pln"> HEAD
    refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master</span></code></pre>

<p>你也可以设置 HEAD 的值：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git symbolic</span><span class="pun">-</span><span class="kwd">ref</span><span class="pln"> HEAD refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">test
    $ cat </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">HEAD
    </span><span class="kwd">ref</span><span class="pun">:</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">test</span></code></pre>

<p>但是你不能设置成 refs 以外的形式：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git symbolic</span><span class="pun">-</span><span class="kwd">ref</span><span class="pln"> HEAD test
    fatal</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Refusing</span><span class="pln"> to point HEAD outside of refs</span><span class="pun">/</span></code></pre>

<h3>Tags</h3>

<p>你刚刚已经重温过了 Git 的三个主要对象类型，现在这是第四种。Tag 对象非常像一个 commit 对象——包含一个标签，一组数据，一个消息和一个指针。最主要的区别就是 Tag 对象指向一个 commit 而不是一个
    tree。它就像是一个分支引用，但是不会变化——永远指向同一个 commit，仅仅是提供一个更加友好的名字。</p>

<p>正如我们在第二章所讨论的，Tag 有两种类型：annotated 和 lightweight 。你可以类似下面这样的命令建立一个 lightweight tag：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git update</span><span class="pun">-</span><span class="kwd">ref</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">tags</span><span class="pun">/</span><span class="pln">v1</span><span class="pun">.</span><span class="lit">0</span><span class="pln"> cac0cab538b970a37ea1e769cbbde608743bc96d</span></code></pre>

<p>这就是 lightweight tag 的全部 —— 一个永远不会发生变化的分支。 annotated tag 要更复杂一点。如果你创建一个 annotated tag，Git 会创建一个 tag
    对象，然后写入一个指向指向它而不是直接指向 commit 的 reference。你可以这样创建一个 annotated tag（<code>-a</code> 参数表明这是一个 annotated tag）：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git tag </span><span class="pun">-</span><span class="pln">a v1</span><span class="pun">.</span><span class="lit">1</span><span class="pln"> </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln"> </span><span class="pun">-</span><span class="pln">m </span><span class="str">'test tag'</span></code></pre>

<p>这是所创建对象的 SHA-1 值：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ cat </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">tags</span><span class="pun">/</span><span class="pln">v1</span><span class="pun">.</span><span class="lit">1</span><span class="pln">
    </span><span class="lit">9585191f37f7b0fb9444f35a9bf50de191beadc2</span></code></pre>

<p>现在你可以运行 <code>cat-file</code> 命令检查这个 SHA-1 值：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p </span><span class="lit">9585191f37f7b0fb9444f35a9bf50de191beadc2</span><span class="pln">
    </span><span class="kwd">object</span><span class="pln"> </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln">
    type commit
    tag v1</span><span class="pun">.</span><span class="lit">1</span><span class="pln">
    tagger </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln"> </span><span class="typ">Sat</span><span class="pln"> </span><span class="typ">May</span><span class="pln"> </span><span class="lit">23</span><span class="pln"> </span><span class="lit">16</span><span class="pun">:</span><span class="lit">48</span><span class="pun">:</span><span class="lit">58</span><span class="pln"> </span><span class="lit">2009</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">

    test tag</span></code></pre>

<p>值得注意的是这个对象指向你所标记的 commit 对象的 SHA-1 值。同时需要注意的是它并不是必须要指向一个 commit 对象；你可以标记任何 Git 对象。例如，在 Git 的源代码里，管理者添加了一个 GPG 公钥（这是一个
    blob 对象）对它做了一个标签。你就可以运行：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file blob junio</span><span class="pun">-</span><span class="pln">gpg</span><span class="pun">-</span><span class="pln">pub</span></code></pre>

<p>来查看 Git 源代码仓库中的公钥. Linux kernel 也有一个不是指向 commit 对象的 tag —— 第一个 tag 是在导入源代码的时候创建的，它指向初始 tree （initial tree，译者注）。</p>

<h3>Remotes</h3>

<p>你将会看到的第四种 reference 是 remote reference（远程引用，译者注）。如果你添加了一个 remote 然后推送代码过去，Git 会把你最后一次推送到这个 remote 的每个分支的值都记录在 <code>refs/remotes</code>
    目录下。例如，你可以添加一个叫做 <code>origin</code> 的 remote 然后把你的 <code>master</code> 分支推送上去：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git remote add origin git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">schacon</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">.</span><span class="pln">git
    $ git push origin master
    </span><span class="typ">Counting</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">11</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Compressing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">5</span><span class="pun">/</span><span class="lit">5</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Writing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">7</span><span class="pun">/</span><span class="lit">7</span><span class="pun">),</span><span class="pln"> </span><span class="lit">716</span><span class="pln"> bytes</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Total</span><span class="pln"> </span><span class="lit">7</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">2</span><span class="pun">),</span><span class="pln"> reused </span><span class="lit">4</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">1</span><span class="pun">)</span><span class="pln">
    </span><span class="typ">To</span><span class="pln"> git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">schacon</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">.</span><span class="pln">git
    a11bef0</span><span class="pun">..</span><span class="pln">ca82a6d master </span><span class="pun">-&gt;</span><span class="pln"> master</span></code></pre>

<p>然后查看 <code>refs/remotes/origin/master</code> 这个文件，你就会发现 <code>origin</code> remote 中的 <code>master</code>
    分支就是你最后一次和服务器的通信。</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ cat </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">master
    ca82a6dff817ec66f44342007202690a93763949</span></code></pre>

<p>Remote 应用和分支主要区别在于他们是不能被 check out 的。Git 把他们当作是标记这些了这些分支在服务器上最后状态的一种书签。</p>

<h2 id="9.4-Packfiles"><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.4-Packfiles">9.4 Packfiles</a></h2>

<p>我们再来看一下 test Git 仓库。目前为止，有 11 个对象 ── 4 个 blob，3 个 tree，3 个 commit 以及一个 tag：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects </span><span class="pun">-</span><span class="pln">type f
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">01</span><span class="pun">/</span><span class="lit">55eb4229851634a0f03eb265b69f5a2d56f341</span><span class="pln"> </span><span class="com"># tree 2</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">1a</span><span class="pun">/</span><span class="lit">410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln"> </span><span class="com"># commit 3</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">1f</span><span class="pun">/</span><span class="lit">7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><span class="pln"> </span><span class="com"># test.txt v2</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">3c</span><span class="pun">/</span><span class="lit">4e9cd789d88d8d89c1073707c3585e41b0e614</span><span class="pln"> </span><span class="com"># tree 3</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">83</span><span class="pun">/</span><span class="pln">baae61804e65cc73a7201a7252750c76066a30 </span><span class="com"># test.txt v1</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">95</span><span class="pun">/</span><span class="lit">85191f37f7b0fb9444f35a9bf50de191beadc2</span><span class="pln"> </span><span class="com"># tag</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">ca</span><span class="pun">/</span><span class="pln">c0cab538b970a37ea1e769cbbde608743bc96d </span><span class="com"># commit 2</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">d6</span><span class="pun">/</span><span class="lit">70460b4b4aece5915caf5c68d12f560a9fe3e4</span><span class="pln"> </span><span class="com"># 'test content'</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">d8</span><span class="pun">/</span><span class="lit">329fc1cc938780ffdd9f94e0d364e0ea74f579</span><span class="pln"> </span><span class="com"># tree 1</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">fa</span><span class="pun">/</span><span class="lit">49b077972391ad58037050f2a75f74e3671e92</span><span class="pln"> </span><span class="com"># new.txt</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">fd</span><span class="pun">/</span><span class="pln">f4fc3344e67ab068f836878b6c4951e3b15f3d </span><span class="com"># commit 1</span></code></pre>

<p>Git 用 zlib 压缩文件内容，因此这些文件并没有占用太多空间，所有文件加起来总共仅用了 925 字节。接下去你会添加一些大文件以演示 Git 的一个很有意思的功能。将你之前用到过的 Grit 库中的 repo.rb 文件加进去
    ── 这个源代码文件大小约为 12K：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ curl http</span><span class="pun">:</span><span class="com">//github.com/mojombo/grit/raw/master/lib/grit/repo.rb &gt; repo.rb</span><span class="pln">
    $ git add repo</span><span class="pun">.</span><span class="pln">rb
    $ git commit </span><span class="pun">-</span><span class="pln">m </span><span class="str">'added repo.rb'</span><span class="pln">
    </span><span class="pun">[</span><span class="pln">master </span><span class="lit">484a592</span><span class="pun">]</span><span class="pln"> added repo</span><span class="pun">.</span><span class="pln">rb
    </span><span class="lit">3</span><span class="pln"> files changed</span><span class="pun">,</span><span class="pln"> </span><span class="lit">459</span><span class="pln"> insertions</span><span class="pun">(+),</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> deletions</span><span class="pun">(-)</span><span class="pln">
    </span><span class="kwd">delete</span><span class="pln"> mode </span><span class="lit">100644</span><span class="pln"> bak</span><span class="pun">/</span><span class="pln">test</span><span class="pun">.</span><span class="pln">txt
    create mode </span><span class="lit">100644</span><span class="pln"> repo</span><span class="pun">.</span><span class="pln">rb
    rewrite test</span><span class="pun">.</span><span class="pln">txt </span><span class="pun">(</span><span class="lit">100</span><span class="pun">%)</span></code></pre>

<p>如果查看一下生成的 tree，可以看到 repo.rb 文件的 blob 对象的 SHA-1 值：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p master</span><span class="pun">^{</span><span class="pln">tree</span><span class="pun">}</span><span class="pln">
    </span><span class="lit">100644</span><span class="pln"> blob fa49b077972391ad58037050f2a75f74e3671e92 </span><span class="kwd">new</span><span class="pun">.</span><span class="pln">txt
    </span><span class="lit">100644</span><span class="pln"> blob </span><span class="lit">9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e</span><span class="pln"> repo</span><span class="pun">.</span><span class="pln">rb
    </span><span class="lit">100644</span><span class="pln"> blob e3f094f522629ae358806b17daf78246c27c007b test</span><span class="pun">.</span><span class="pln">txt</span></code></pre>

<p>然后可以用 <code>git cat-file</code> 命令查看这个对象有多大：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">s </span><span class="lit">9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e</span><span class="pln">
    </span><span class="lit">12898</span></code></pre>

<p>稍微修改一下些文件，看会发生些什么：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ echo </span><span class="str">'# testing'</span><span class="pln"> </span><span class="pun">&gt;&gt;</span><span class="pln"> repo</span><span class="pun">.</span><span class="pln">rb
    $ git commit </span><span class="pun">-</span><span class="pln">am </span><span class="str">'modified repo a bit'</span><span class="pln">
    </span><span class="pun">[</span><span class="pln">master ab1afef</span><span class="pun">]</span><span class="pln"> modified repo a bit
    </span><span class="lit">1</span><span class="pln"> files changed</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> insertions</span><span class="pun">(+),</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> deletions</span><span class="pun">(-)</span></code></pre>

<p>查看这个 commit 生成的 tree，可以看到一些有趣的东西：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p master</span><span class="pun">^{</span><span class="pln">tree</span><span class="pun">}</span><span class="pln">
    </span><span class="lit">100644</span><span class="pln"> blob fa49b077972391ad58037050f2a75f74e3671e92 </span><span class="kwd">new</span><span class="pun">.</span><span class="pln">txt
    </span><span class="lit">100644</span><span class="pln"> blob </span><span class="lit">05408d195263d853f09dca71d55116663690c27c</span><span class="pln"> repo</span><span class="pun">.</span><span class="pln">rb
    </span><span class="lit">100644</span><span class="pln"> blob e3f094f522629ae358806b17daf78246c27c007b test</span><span class="pun">.</span><span class="pln">txt</span></code></pre>

<p>blob 对象与之前的已经不同了。这说明虽然只是往一个 400 行的文件最后加入了一行内容，Git 却用一个全新的对象来保存新的文件内容：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">s </span><span class="lit">05408d195263d853f09dca71d55116663690c27c</span><span class="pln">
    </span><span class="lit">12908</span></code></pre>

<p>你的磁盘上有了两个几乎完全相同的 12K 的对象。如果 Git 只完整保存其中一个，并保存另一个对象的差异内容，岂不更好？</p>

<p>事实上 Git 可以那样做。Git 往磁盘保存对象时默认使用的格式叫松散对象 (loose object) 格式。Git 时不时地将这些对象打包至一个叫 packfile
    的二进制文件以节省空间并提高效率。当仓库中有太多的松散对象，或是手工调用 <code>git gc</code> 命令，或推送至远程服务器时，Git 都会这样做。手工调用 <code>git gc</code> 命令让 Git
    将库中对象打包并看会发生些什么：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git gc
    </span><span class="typ">Counting</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">17</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Delta</span><span class="pln"> compression </span><span class="kwd">using</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> threads</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Compressing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">13</span><span class="pun">/</span><span class="lit">13</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Writing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">17</span><span class="pun">/</span><span class="lit">17</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Total</span><span class="pln"> </span><span class="lit">17</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">1</span><span class="pun">),</span><span class="pln"> reused </span><span class="lit">10</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">0</span><span class="pun">)</span></code></pre>

<p>查看一下 objects 目录，会发现大部分对象都不在了，与此同时出现了两个新文件：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects </span><span class="pun">-</span><span class="pln">type f
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="lit">71</span><span class="pun">/</span><span class="lit">08f7ecb345ee9d0084193f147cdad4d2998293</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">d6</span><span class="pun">/</span><span class="lit">70460b4b4aece5915caf5c68d12f560a9fe3e4</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">info</span><span class="pun">/</span><span class="pln">packs
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">-</span><span class="lit">7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">-</span><span class="lit">7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack</span></code></pre>

<p>仍保留着的几个对象是未被任何 commit 引用的 blob ── 在此例中是你之前创建的 "what is up, doc?" 和 "test content" 这两个示例
    blob。你从没将他们添加至任何 commit，所以 Git 认为它们是 "悬空" 的，不会将它们打包进 packfile 。</p>

<p>剩下的文件是新创建的 packfile 以及一个索引。packfile 文件包含了刚才从文件系统中移除的所有对象。索引文件包含了 packfile 的偏移信息，这样就可以快速定位任意一个指定对象。有意思的是运行
    <code>gc</code> 命令前磁盘上的对象大小约为 12K ，而这个新生成的 packfile 仅为 6K 大小。通过打包对象减少了一半磁盘使用空间。</p>

<p>Git 是如何做到这点的？Git 打包对象时，会查找命名及尺寸相近的文件，并只保存文件不同版本之间的差异内容。可以查看一下 packfile ，观察它是如何节省空间的。<code>git verify-pack</code>
    命令用于显示已打包的内容：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git verify</span><span class="pun">-</span><span class="pln">pack </span><span class="pun">-</span><span class="pln">v \
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">-</span><span class="lit">7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx</span><span class="pln">
    </span><span class="lit">0155eb4229851634a0f03eb265b69f5a2d56f341</span><span class="pln"> tree </span><span class="lit">71</span><span class="pln"> </span><span class="lit">76</span><span class="pln"> </span><span class="lit">5400</span><span class="pln">
    </span><span class="lit">05408d195263d853f09dca71d55116663690c27c</span><span class="pln"> blob </span><span class="lit">12908</span><span class="pln"> </span><span class="lit">3478</span><span class="pln"> </span><span class="lit">874</span><span class="pln">
    </span><span class="lit">09f01cea547666f58d6a8d809583841a7c6f0130</span><span class="pln"> tree </span><span class="lit">106</span><span class="pln"> </span><span class="lit">107</span><span class="pln"> </span><span class="lit">5086</span><span class="pln">
    </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln"> commit </span><span class="lit">225</span><span class="pln"> </span><span class="lit">151</span><span class="pln"> </span><span class="lit">322</span><span class="pln">
    </span><span class="lit">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><span class="pln"> blob </span><span class="lit">10</span><span class="pln"> </span><span class="lit">19</span><span class="pln"> </span><span class="lit">5381</span><span class="pln">
    </span><span class="lit">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><span class="pln"> tree </span><span class="lit">101</span><span class="pln"> </span><span class="lit">105</span><span class="pln"> </span><span class="lit">5211</span><span class="pln">
    </span><span class="lit">484a59275031909e19aadb7c92262719cfcdf19a</span><span class="pln"> commit </span><span class="lit">226</span><span class="pln"> </span><span class="lit">153</span><span class="pln"> </span><span class="lit">169</span><span class="pln">
    </span><span class="lit">83baae61804e65cc73a7201a7252750c76066a30</span><span class="pln"> blob </span><span class="lit">10</span><span class="pln"> </span><span class="lit">19</span><span class="pln"> </span><span class="lit">5362</span><span class="pln">
    </span><span class="lit">9585191f37f7b0fb9444f35a9bf50de191beadc2</span><span class="pln"> tag </span><span class="lit">136</span><span class="pln"> </span><span class="lit">127</span><span class="pln"> </span><span class="lit">5476</span><span class="pln">
    </span><span class="lit">9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e</span><span class="pln"> blob </span><span class="lit">7</span><span class="pln"> </span><span class="lit">18</span><span class="pln"> </span><span class="lit">5193</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> \
    </span><span class="lit">05408d195263d853f09dca71d55116663690c27c</span><span class="pln">
    ab1afef80fac8e34258ff41fc1b867c702daa24b commit </span><span class="lit">232</span><span class="pln"> </span><span class="lit">157</span><span class="pln"> </span><span class="lit">12</span><span class="pln">
    cac0cab538b970a37ea1e769cbbde608743bc96d commit </span><span class="lit">226</span><span class="pln"> </span><span class="lit">154</span><span class="pln"> </span><span class="lit">473</span><span class="pln">
    d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree </span><span class="lit">36</span><span class="pln"> </span><span class="lit">46</span><span class="pln"> </span><span class="lit">5316</span><span class="pln">
    e3f094f522629ae358806b17daf78246c27c007b blob </span><span class="lit">1486</span><span class="pln"> </span><span class="lit">734</span><span class="pln"> </span><span class="lit">4352</span><span class="pln">
    f8f51d7d8a1760462eca26eebafde32087499533 tree </span><span class="lit">106</span><span class="pln"> </span><span class="lit">107</span><span class="pln"> </span><span class="lit">749</span><span class="pln">
    fa49b077972391ad58037050f2a75f74e3671e92 blob </span><span class="lit">9</span><span class="pln"> </span><span class="lit">18</span><span class="pln"> </span><span class="lit">856</span><span class="pln">
    fdf4fc3344e67ab068f836878b6c4951e3b15f3d commit </span><span class="lit">177</span><span class="pln"> </span><span class="lit">122</span><span class="pln"> </span><span class="lit">627</span><span class="pln">
    chain length </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="kwd">object</span><span class="pln">
    pack</span><span class="pun">-</span><span class="lit">7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack</span><span class="pun">:</span><span class="pln"> ok</span></code></pre>

<p>如果你还记得的话, <code>9bc1d</code> 这个 blob 是 repo.rb 文件的第一个版本，这个 blob 引用了 <code>05408</code> 这个
    blob，即该文件的第二个版本。命令输出内容的第三列显示的是对象大小，可以看到 <code>05408</code> 占用了 12K 空间，而 <code>9bc1d</code> 仅为 7
    字节。非常有趣的是第二个版本才是完整保存文件内容的对象，而第一个版本是以差异方式保存的 ── 这是因为大部分情况下需要快速访问文件的最新版本。</p>

<p>最妙的是可以随时进行重新打包。Git 自动定期对仓库进行重新打包以节省空间。当然也可以手工运行 <code>git gc</code> 命令来这么做。</p>

<h2 id="9.5-The-Refspec"><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.5-The-Refspec">9.5 The Refspec</a></h2>

<p>这本书读到这里，你已经使用过一些简单的远程分支到本地引用的映射方式了，这种映射可以更为复杂。
    假设你像这样添加了一项远程仓库：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git remote add origin git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">schacon</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">.</span><span class="pln">git</span></code></pre>

<p>它在你的 <code>.git/config</code> 文件中添加了一节，指定了远程的名称 (<code>origin</code>), 远程仓库的URL地址，和用于获取操作的 Refspec:</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">[</span><span class="pln">remote </span><span class="str">"origin"</span><span class="pun">]</span><span class="pln">
    url </span><span class="pun">=</span><span class="pln"> git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">schacon</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">.</span><span class="pln">git
    fetch </span><span class="pun">=</span><span class="pln"> </span><span class="pun">+</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="com">/*:refs/remotes/origin/*</span></code></pre>

<p>Refspec 的格式是一个可选的 <code>+</code> 号，接着是 <code>&lt;src&gt;:&lt;dst&gt;</code> 的格式，这里 <code>&lt;src&gt;</code>
    是远端上的引用格式， <code>&lt;dst&gt;</code> 是将要记录在本地的引用格式。可选的 <code>+</code> 号告诉 Git 在即使不能快速演进的情况下，也去强制更新它。</p>

<p>缺省情况下 refspec 会被 <code>git remote add</code> 命令所自动生成， Git 会获取远端上 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code>.
    所以，如果远端上有一个 <code>master</code> 分支，你在本地可以通过下面这种方式来访问它的历史记录：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git log origin</span><span class="pun">/</span><span class="pln">master
    $ git log remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">master
    $ git log refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">master</span></code></pre>

<p>它们全是等价的，因为 Git 把它们都扩展成 <code>refs/remotes/origin/master</code>.</p>

<p>如果你想让 Git 每次只拉取远程的 <code>master</code> 分支，而不是远程的所有分支，你可以把 fetch 这一行修改成这样：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">fetch </span><span class="pun">=</span><span class="pln"> </span><span class="pun">+</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master</span><span class="pun">:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">master</span></code></pre>

<p>这是 <code>git fetch</code> 操作对这个远端的缺省 refspec 值。而如果你只想做一次该操作，也可以在命令行上指定这个 refspec. 如可以这样拉取远程的 <code>master</code>
    分支到本地的 <code>origin/mymaster</code> 分支：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git fetch origin master</span><span class="pun">:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">mymaster</span></code></pre>

<p>你也可以在命令行上指定多个 refspec. 像这样可以一次获取远程的多个分支：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git fetch origin master</span><span class="pun">:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">mymaster \
    topic</span><span class="pun">:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">topic
    </span><span class="typ">From</span><span class="pln"> git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">schacon</span><span class="pun">/</span><span class="pln">simplegit
    </span><span class="pun">!</span><span class="pln"> </span><span class="pun">[</span><span class="pln">rejected</span><span class="pun">]</span><span class="pln"> master </span><span class="pun">-&gt;</span><span class="pln"> origin</span><span class="pun">/</span><span class="pln">mymaster </span><span class="pun">(</span><span class="pln">non fast forward</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">*</span><span class="pln"> </span><span class="pun">[</span><span class="kwd">new</span><span class="pln"> branch</span><span class="pun">]</span><span class="pln"> topic </span><span class="pun">-&gt;</span><span class="pln"> origin</span><span class="pun">/</span><span class="pln">topic</span></code></pre>

<p>在这个例子中， <code>master</code> 分支因为不是一个可以快速演进的引用而拉取操作被拒绝。你可以在 refspec 之前使用一个 <code>+</code> 号来重载这种行为。</p>

<p>你也可以在配置文件中指定多个 refspec. 如你想在每次获取时都获取 <code>master</code> 和 <code>experiment</code> 分支，就添加两行：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">[</span><span class="pln">remote </span><span class="str">"origin"</span><span class="pun">]</span><span class="pln">
    url </span><span class="pun">=</span><span class="pln"> git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">schacon</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">.</span><span class="pln">git
    fetch </span><span class="pun">=</span><span class="pln"> </span><span class="pun">+</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master</span><span class="pun">:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">master
    fetch </span><span class="pun">=</span><span class="pln"> </span><span class="pun">+</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">experiment</span><span class="pun">:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">experiment</span></code></pre>

<p>但是这里不能使用部分通配符，像这样就是不合法的：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">fetch </span><span class="pun">=</span><span class="pln"> </span><span class="pun">+</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">qa</span><span class="pun">*:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">qa</span><span class="pun">*</span></code></pre>

<p>但无论如何，你可以使用命名空间来达到这个目的。如你有一个QA组，他们推送一系列分支，你想每次获取 <code>master</code> 分支和QA组的所有分支，你可以使用这样的配置段落：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">[</span><span class="pln">remote </span><span class="str">"origin"</span><span class="pun">]</span><span class="pln">
    url </span><span class="pun">=</span><span class="pln"> git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">schacon</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">.</span><span class="pln">git
    fetch </span><span class="pun">=</span><span class="pln"> </span><span class="pun">+</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master</span><span class="pun">:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">remotes</span><span class="pun">/</span><span class="pln">origin</span><span class="pun">/</span><span class="pln">master
    fetch </span><span class="pun">=</span><span class="pln"> </span><span class="pun">+</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">qa</span><span class="com">/*:refs/remotes/origin/qa/*</span></code></pre>

<p>如果你的工作流很复杂，有QA组推送的分支、开发人员推送的分支、和集成人员推送的分支，并且他们在远程分支上协作，你可以采用这种方式为他们创建各自的命名空间。</p>

<h3>推送 Refspec</h3>

<p>采用命名空间的方式确实很棒，但QA组成员第1次是如何将他们的分支推送到 <code>qa/</code> 空间里面的呢？答案是你可以使用 refspec 来推送。</p>

<p>如果QA组成员想把他们的 <code>master</code> 分支推送到远程的 <code>qa/master</code> 分支上，可以这样运行：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git push origin master</span><span class="pun">:</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">qa</span><span class="pun">/</span><span class="pln">master</span></code></pre>

<p>如果他们想让 Git 每次运行 <code>git push origin</code> 时都这样自动推送，他们可以在配置文件中添加 <code>push</code> 值：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">[</span><span class="pln">remote </span><span class="str">"origin"</span><span class="pun">]</span><span class="pln">
    url </span><span class="pun">=</span><span class="pln"> git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">schacon</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">.</span><span class="pln">git
    fetch </span><span class="pun">=</span><span class="pln"> </span><span class="pun">+</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="com">/*:refs/remotes/origin/*
    push = refs/heads/master:refs/heads/qa/master</span></code></pre>

<p>这样，就会让 <code>git push origin</code> 缺省就把本地的 <code>master</code> 分支推送到远程的 <code>qa/master</code> 分支上。</p>

<h3>删除引用</h3>

<p>你也可以使用 refspec 来删除远程的引用，是通过运行这样的命令：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git push origin </span><span class="pun">:</span><span class="pln">topic</span></code></pre>

<p>因为 refspec 的格式是 <code>&lt;src&gt;:&lt;dst&gt;</code>, 通过把 <code>&lt;src&gt;</code> 部分留空的方式，这个意思是是把远程的
    <code>topic</code> 分支变成空，也就是删除它。</p>

<h2 id="9.6-传输协议"><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.6-%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">9.6 传输协议</a></h2>

<p>Git 可以以两种主要的方式跨越两个仓库传输数据：基于HTTP协议之上，和 <code>file://</code>, <code>ssh://</code>, 和 <code>git://</code>
    等智能传输协议。这一节带你快速浏览这两种主要的协议操作过程。</p>

<h3>哑协议</h3>

<p>Git 基于HTTP之上传输通常被称为哑协议，这是因为它在服务端不需要有针对 Git 特有的代码。这个获取过程仅仅是一系列GET请求，客户端可以假定服务端的Git仓库中的布局。让我们以 simplegit 库来看看 <code>http-fetch</code>
    的过程：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git clone http</span><span class="pun">:</span><span class="com">//github.com/schacon/simplegit-progit.git</span></code></pre>

<p>它做的第1件事情就是获取 <code>info/refs</code> 文件。这个文件是在服务端运行了 <code>update-server-info</code> 所生成的，这也解释了为什么在服务端要想使用HTTP传输，必须要开启
    <code>post-receive</code> 钩子：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET info</span><span class="pun">/</span><span class="pln">refs
    ca82a6dff817ec66f44342007202690a93763949 refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master</span></code></pre>

<p>现在你有一个远端引用和SHA值的列表。下一步是寻找HEAD引用，这样你就知道了在完成后，什么应该被检出到工作目录：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET HEAD
    </span><span class="kwd">ref</span><span class="pun">:</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master</span></code></pre>

<p>这说明在完成获取后，需要检出 <code>master</code> 分支。
    这时，已经可以开始漫游操作了。因为你的起点是在 <code>info/refs</code> 文件中所提到的 <code>ca82a6</code> commit 对象，你的开始操作就是获取它：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET objects</span><span class="pun">/</span><span class="pln">ca</span><span class="pun">/</span><span class="lit">82a6dff817ec66f44342007202690a93763949</span><span class="pln">
    </span><span class="pun">(</span><span class="lit">179</span><span class="pln"> bytes of binary data</span><span class="pun">)</span></code></pre>

<p>然后你取回了这个对象 － 这在服务端是一个松散格式的对象，你使用的是静态的 HTTP GET 请求获取的。可以使用 zlib 解压缩它，去除其头部，查看它的 commmit 内容：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git cat</span><span class="pun">-</span><span class="pln">file </span><span class="pun">-</span><span class="pln">p ca82a6dff817ec66f44342007202690a93763949
    tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
    parent </span><span class="lit">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><span class="pln">
    author </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">1205815931</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">
    committer </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">1240030591</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">

    changed the version number</span></code></pre>

<p>这样，就得到了两个需要进一步获取的对象 － <code>cfda3b</code> 是这个 commit 对象所对应的 tree 对象，和 <code>085bb3</code> 是它的父对象；</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET objects</span><span class="pun">/</span><span class="lit">08</span><span class="pun">/</span><span class="lit">5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><span class="pln">
    </span><span class="pun">(</span><span class="lit">179</span><span class="pln"> bytes of data</span><span class="pun">)</span></code></pre>

<p>这样就取得了这它的下一步 commit 对象，再抓取 tree 对象：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET objects</span><span class="pun">/</span><span class="pln">cf</span><span class="pun">/</span><span class="pln">da3bf379e4f8dba8717dee55aab78aef7f4daf
    </span><span class="pun">(</span><span class="lit">404</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="typ">Not</span><span class="pln"> </span><span class="typ">Found</span><span class="pun">)</span></code></pre>

<p>Oops - 看起来这个 tree 对象在服务端并不以松散格式对象存在，所以得到了404响应，代表在HTTP服务端没有找到该对象。这有好几个原因 － 这个对象可能在替代仓库里面，或者在打包文件里面， Git
    会首先检查任何列出的替代仓库：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET objects</span><span class="pun">/</span><span class="pln">info</span><span class="pun">/</span><span class="pln">http</span><span class="pun">-</span><span class="pln">alternates
    </span><span class="pun">(</span><span class="pln">empty file</span><span class="pun">)</span></code></pre>

<p>如果这返回了几个替代仓库列表，那么它会去那些地方检查松散格式对象和文件 －
    这是一种在软件分叉之间共享对象以节省磁盘的好方法。然而，在这个例子中，没有替代仓库。所以你所需要的对象肯定在某个打包文件中。要检查服务端有哪些打包格式文件，你需要获取 <code>objects/info/packs</code>
    文件，这里面包含有打包文件列表（是的，它也是被 <code>update-server-info</code> 所生成的）；</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET objects</span><span class="pun">/</span><span class="pln">info</span><span class="pun">/</span><span class="pln">packs
    P pack</span><span class="pun">-</span><span class="lit">816a9b2334da9953e530f27bcac22082a9f5b835.pack</span></code></pre>

<p>这里服务端只有一个打包文件，所以你要的对象显然就在里面。但是你可以先检查它的索引文件以确认。这在服务端有多个打包文件时也很有用，因为这样就可以先检查你所需要的对象空间是在哪一个打包文件里面了：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET objects</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">-</span><span class="lit">816a9b2334da9953e530f27bcac22082a9f5b835.idx</span><span class="pln">
    </span><span class="pun">(</span><span class="lit">4k</span><span class="pln"> of binary data</span><span class="pun">)</span></code></pre>

<p>现在你有了这个打包文件的索引，你可以看看你要的对象是否在里面 － 因为索引文件列出了这个打包文件所包含的所有对象的SHA值，和该对象存在于打包文件中的偏移量，所以你只需要简单地获取整个打包文件：</p>

<pre class="prettyprint prettyprinted"><code><span class="pun">=&gt;</span><span class="pln"> GET objects</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">-</span><span class="lit">816a9b2334da9953e530f27bcac22082a9f5b835.pack</span><span class="pln">
    </span><span class="pun">(</span><span class="lit">13k</span><span class="pln"> of binary data</span><span class="pun">)</span></code></pre>

<p>现在你也有了这个 tree 对象，你可以继续在 commit 对象上漫游。它们全部都在这个你已经下载到的打包文件里面，所以你不用继续向服务端请求更多下载了。 在这完成之后，由于下载开始时已探明HEAD引用是指向 <code>master</code>
    分支， Git 会将它检出到工作目录。</p>

<p>整个过程看起来就像这样：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git clone http</span><span class="pun">:</span><span class="com">//github.com/schacon/simplegit-progit.git</span><span class="pln">
    </span><span class="typ">Initialized</span><span class="pln"> empty </span><span class="typ">Git</span><span class="pln"> repository </span><span class="kwd">in</span><span class="pln"> </span><span class="pun">/</span><span class="kwd">private</span><span class="pun">/</span><span class="pln">tmp</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">/.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">
    got ca82a6dff817ec66f44342007202690a93763949
    walk ca82a6dff817ec66f44342007202690a93763949
    got </span><span class="lit">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><span class="pln">
    </span><span class="typ">Getting</span><span class="pln"> alternates list </span><span class="kwd">for</span><span class="pln"> http</span><span class="pun">:</span><span class="com">//github.com/schacon/simplegit-progit.git</span><span class="pln">
    </span><span class="typ">Getting</span><span class="pln"> pack list </span><span class="kwd">for</span><span class="pln"> http</span><span class="pun">:</span><span class="com">//github.com/schacon/simplegit-progit.git</span><span class="pln">
    </span><span class="typ">Getting</span><span class="pln"> index </span><span class="kwd">for</span><span class="pln"> pack </span><span class="lit">816a9b2334da9953e530f27bcac22082a9f5b835</span><span class="pln">
    </span><span class="typ">Getting</span><span class="pln"> pack </span><span class="lit">816a9b2334da9953e530f27bcac22082a9f5b835</span><span class="pln">
    which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf
    walk </span><span class="lit">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><span class="pln">
    walk a11bef06a3f659402fe7563abf99ad00de2209e6</span></code></pre>

<h3>智能协议</h3>

<p>这个HTTP方法是很简单但效率不是很高。使用智能协议是传送数据的更常用的方法。这些协议在远端都有Git智能型进程在服务 －
    它可以读出本地数据并计算出客户端所需要的，并生成合适的数据给它，这有两类传输数据的进程：一对用于上传数据和一对用于下载。</p>

<h4>上传数据</h4>

<p>为了上传数据至远端， Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。这个 <code>send-pack</code> 进程运行在客户端上，它连接至远端运行的
    <code>receive-pack</code> 进程。</p>

<p>举例来说，你在你的项目上运行了 <code>git push origin master</code>, 并且 <code>origin</code> 被定义为一个使用SSH协议的URL。 Git 会使用 <code>send-pack</code>
    进程，它会启动一个基于SSH的连接到服务器。它尝试像这样透过SSH在服务端运行命令：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ ssh </span><span class="pun">-</span><span class="pln">x git@github</span><span class="pun">.</span><span class="pln">com </span><span class="str">"git-receive-pack 'schacon/simplegit-progit.git'"</span><span class="pln">
    </span><span class="lit">005bca82a6dff817ec66f4437202690a93763949</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master report</span><span class="pun">-</span><span class="pln">status </span><span class="kwd">delete</span><span class="pun">-</span><span class="pln">refs
    </span><span class="lit">003e085bb3bcb608e1e84b2432f8ecbe6306e7e7</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">topic
    </span><span class="lit">0000</span></code></pre>

<p>这里的 <code>git-receive-pack</code> 命令会立即对它所拥有的每一个引用响应一行 － 在这个例子中，只有 <code>master</code>
    分支和它的SHA值。这里第1行也包含了服务端的能力列表（这里是 <code>report-status</code> 和 <code>delete-refs</code>）。</p>

<p>
    每一行以4字节的十六进制开始，用于指定整行的长度。你看到第1行以005b开始，这在十六进制中表示91，意味着第1行有91字节长。下一行以003e起始，表示有62字节长，所以需要读剩下的62字节。再下一行是0000开始，表示服务器已完成了引用列表过程。</p>

<p>现在它知道了服务端的状态，你的 <code>send-pack</code> 进程会判断哪些 commit 是它所拥有但服务端没有的。针对每个引用，这次推送都会告诉对端的 <code>receive-pack</code>
    这个信息。举例说，如果你在更新 <code>master</code> 分支，并且增加 <code>experiment</code> 分支，这个 <code>send-pack</code> 将会是像这样：</p>

<pre class="prettyprint prettyprinted"><code><span class="lit">0085ca82a6dff817ec66f44342007202690a93763949</span><span class="pln"> </span><span class="lit">15027957951b64cf874c3557a0f3547bd83b3ff6</span><span class="pln">
    refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master report</span><span class="pun">-</span><span class="pln">status
    </span><span class="lit">00670000000000000000000000000000000000000000</span><span class="pln"> cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">experiment
    </span><span class="lit">0000</span></code></pre>

<p>这里的全'0'的SHA-1值表示之前没有过这个对象 － 因为你是在添加新的 experiment 引用。如果你在删除一个引用，你会看到相反的： 就是右边是全'0'。</p>

<p>Git
    针对每个引用发送这样一行信息，就是旧的SHA值，新的SHA值，和将要更新的引用的名称。第1行还会包含有客户端的能力。下一步，客户端会发送一个所有那些服务端所没有的对象的一个打包文件。最后，服务端以成功(或者失败)来响应：</p>

<pre class="prettyprint prettyprinted"><code><span class="lit">000Aunpack</span><span class="pln"> ok</span></code></pre>

<h4>下载数据</h4>

<p>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code>
    进程，以协商后续数据传输过程。</p>

<p>在远端仓库有不同的方式启动 <code>upload-pack</code> 进程。你可以使用与 <code>receive-pack</code> 相同的透过SSH管道的方式，也可以通过 Git
    后台来启动这个进程，它默认监听在9418号端口上。这里 <code>fetch-pack</code> 进程在连接后像这样向后台发送数据：</p>

<pre class="prettyprint prettyprinted"><code><span class="lit">003fgit</span><span class="pun">-</span><span class="pln">upload</span><span class="pun">-</span><span class="pln">pack schacon</span><span class="pun">/</span><span class="pln">simplegit</span><span class="pun">-</span><span class="pln">progit</span><span class="pun">.</span><span class="pln">git\0host</span><span class="pun">=</span><span class="pln">myserver</span><span class="pun">.</span><span class="pln">com\0</span></code></pre>

<p>它也是以4字节指定后续字节长度的方式开始，然后是要运行的命令，和一个空字节，然后是服务端的主机名，再跟随一个最后的空字节。 Git
    后台进程会检查这个命令是否可以运行，以及那个仓库是否存在，以及是否具有公开权限。如果所有检查都通过了，它会启动这个 <code>upload-pack</code> 进程并将客户端的请求移交给它。</p>

<p>如果你透过SSH使用获取功能， <code>fetch-pack</code> 会像这样运行：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ ssh </span><span class="pun">-</span><span class="pln">x git@github</span><span class="pun">.</span><span class="pln">com </span><span class="str">"git-upload-pack 'schacon/simplegit-progit.git'"</span></code></pre>

<p>不管哪种方式，在 <code>fetch-pack</code> 连接之后， <code>upload-pack</code> 都会以这种形式返回：</p>

<pre class="prettyprint prettyprinted"><code><span class="lit">0088ca82a6dff817ec66f44342007202690a93763949</span><span class="pln"> HEAD\0multi_ack thin</span><span class="pun">-</span><span class="pln">pack \
    side</span><span class="pun">-</span><span class="pln">band side</span><span class="pun">-</span><span class="pln">band</span><span class="pun">-</span><span class="lit">64k</span><span class="pln"> ofs</span><span class="pun">-</span><span class="pln">delta shallow </span><span class="kwd">no</span><span class="pun">-</span><span class="pln">progress include</span><span class="pun">-</span><span class="pln">tag
    </span><span class="lit">003fca82a6dff817ec66f44342007202690a93763949</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master
    </span><span class="lit">003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">topic
    </span><span class="lit">0000</span></code></pre>

<p>这与 <code>receive-pack</code> 响应很类似，但是这里指的能力是不同的。而且它还会指出HEAD引用，让客户端可以检查是否是一份克隆。</p>

<p>在这里， <code>fetch-pack</code> 进程检查它自己所拥有的对象和所有它需要的对象，通过发送 "want" 和所需对象的SHA值，发送 "have"
    和所有它已拥有的对象的SHA值。在列表完成时，再发送 "done" 通知 <code>upload-pack</code> 进程开始发送所需对象的打包文件。这个过程看起来像这样：</p>

<pre class="prettyprint prettyprinted"><code><span class="lit">0054want</span><span class="pln"> ca82a6dff817ec66f44342007202690a93763949 ofs</span><span class="pun">-</span><span class="pln">delta
    </span><span class="lit">0032have</span><span class="pln"> </span><span class="lit">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><span class="pln">
    </span><span class="lit">0000</span><span class="pln">
    </span><span class="lit">0009done</span></code></pre>

<p>这是传输协议的一个很基础的例子，在更复杂的例子中，客户端可能会支持 <code>multi_ack</code> 或者 <code>side-band</code> 能力；但是这个例子中展示了智能协议的基本交互过程。</p>

<h2 id="9.7-维护及数据恢复"><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.7-%E7%BB%B4%E6%8A%A4%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D">9.7 维护及数据恢复</a></h2>

<p>你时不时的需要进行一些清理工作 ── 如减小一个仓库的大小，清理导入的库，或是恢复丢失的数据。本节将描述这类使用场景。</p>

<h3>维护</h3>

<p>Git 会不定时地自动运行称为 "auto gc" 的命令。大部分情况下该命令什么都不处理。不过要是存在太多松散对象 (loose object, 不在 packfile 中的对象) 或 packfile，Git
    会进行调用 <code>git gc</code> 命令。 <code>gc</code> 指垃圾收集 (garbage collect)，此命令会做很多工作：收集所有松散对象并将它们存入 packfile，合并这些
    packfile 进一个大的 packfile，然后将不被任何 commit 引用并且已存在一段时间 (数月) 的对象删除。</p>

<p>可以手工运行 auto gc 命令：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git gc </span><span class="pun">--</span><span class="kwd">auto</span></code></pre>

<p>再次强调，这个命令一般什么都不干。如果有 7,000 个左右的松散对象或是 50 个以上的 packfile，Git 才会真正调用 gc 命令。可能通过修改配置中的 <code>gc.auto</code> 和 <code>gc.autopacklimit</code>
    来调整这两个阈值。</p>

<p><code>gc</code> 还会将所有引用 (references) 并入一个单独文件。假设仓库中包含以下分支和标签：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ find </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs </span><span class="pun">-</span><span class="pln">type f
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">experiment
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">tags</span><span class="pun">/</span><span class="pln">v1</span><span class="pun">.</span><span class="lit">0</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">tags</span><span class="pun">/</span><span class="pln">v1</span><span class="pun">.</span><span class="lit">1</span></code></pre>

<p>这时如果运行 <code>git gc</code>, <code>refs</code> 下的所有文件都会消失。Git 会将这些文件挪到 <code>.git/packed-refs</code>
    文件中去以提高效率，该文件是这个样子的：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ cat </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">packed</span><span class="pun">-</span><span class="pln">refs
    </span><span class="com"># pack-refs with: peeled</span><span class="pln">
    cac0cab538b970a37ea1e769cbbde608743bc96d refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">experiment
    ab1afef80fac8e34258ff41fc1b867c702daa24b refs</span><span class="pun">/</span><span class="pln">heads</span><span class="pun">/</span><span class="pln">master
    cac0cab538b970a37ea1e769cbbde608743bc96d refs</span><span class="pun">/</span><span class="pln">tags</span><span class="pun">/</span><span class="pln">v1</span><span class="pun">.</span><span class="lit">0</span><span class="pln">
    </span><span class="lit">9585191f37f7b0fb9444f35a9bf50de191beadc2</span><span class="pln"> refs</span><span class="pun">/</span><span class="pln">tags</span><span class="pun">/</span><span class="pln">v1</span><span class="pun">.</span><span class="lit">1</span><span class="pln">
    </span><span class="pun">^</span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span></code></pre>

<p>当更新一个引用时，Git 不会修改这个文件，而是在 <code>refs/heads</code> 下写入一个新文件。当查找一个引用的 SHA 时，Git 首先在 <code>refs</code> 目录下查找，如果未找到则到
    <code>packed-refs</code> 文件中去查找。因此如果在 <code>refs</code> 目录下找不到一个引用，该引用可能存到 <code>packed-refs</code> 文件中去了。</p>

<p>请留意文件最后以 <code>^</code> 开头的那一行。这表示该行上一行的那个标签是一个 annotated 标签，而该行正是那个标签所指向的 commit 。</p>

<h3>数据恢复</h3>

<p>在使用 Git 的过程中，有时会不小心丢失 commit 信息。这一般出现在以下情况下：强制删除了一个分支而后又想重新使用这个分支，hard-reset 了一个分支从而丢弃了分支的部分
    commit。如果这真的发生了，有什么办法把丢失的 commit 找回来呢？</p>

<p>下面的示例演示了对 test 仓库主分支进行 hard-reset 到一个老版本的 commit 的操作，然后恢复丢失的 commit 。首先查看一下当前的仓库状态：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git log </span><span class="pun">--</span><span class="pln">pretty</span><span class="pun">=</span><span class="pln">oneline
    ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
    </span><span class="lit">484a59275031909e19aadb7c92262719cfcdf19a</span><span class="pln"> added repo</span><span class="pun">.</span><span class="pln">rb
    </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln"> third commit
    cac0cab538b970a37ea1e769cbbde608743bc96d second commit
    fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span></code></pre>

<p>接着将 <code>master</code> 分支移回至中间的一个 commit：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git reset </span><span class="pun">--</span><span class="pln">hard </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln">
    HEAD </span><span class="kwd">is</span><span class="pln"> now at </span><span class="lit">1a410ef</span><span class="pln"> third commit
    $ git log </span><span class="pun">--</span><span class="pln">pretty</span><span class="pun">=</span><span class="pln">oneline
    </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln"> third commit
    cac0cab538b970a37ea1e769cbbde608743bc96d second commit
    fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span></code></pre>

<p>这样就丢弃了最新的两个 commit ── 包含这两个 commit 的分支不存在了。现在要做的是找出最新的那个 commit 的 SHA，然后添加一个指它它的分支。关键在于找出最新的 commit 的 SHA ──
    你不大可能记住了这个 SHA，是吧？</p>

<p>通常最快捷的办法是使用 <code>git reflog</code> 工具。当你 (在一个仓库下) 工作时，Git 会在你每次修改了 HEAD 时悄悄地将改动记录下来。当你提交或修改分支时，reflog 就会更新。<code>git
    update-ref</code> 命令也可以更新 reflog，这是在本章前面的 "Git References" 部分我们使用该命令而不是手工将 SHA 值写入 ref 文件的理由。任何时间运行 <code>git
    reflog</code> 命令可以查看当前的状态：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git reflog
    </span><span class="lit">1a410ef</span><span class="pln"> HEAD@</span><span class="pun">{</span><span class="lit">0</span><span class="pun">}:</span><span class="pln"> </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pun">:</span><span class="pln"> updating HEAD
    ab1afef HEAD@</span><span class="pun">{</span><span class="lit">1</span><span class="pun">}:</span><span class="pln"> ab1afef80fac8e34258ff41fc1b867c702daa24b</span><span class="pun">:</span><span class="pln"> updating HEAD</span></code></pre>

<p>可以看到我们签出的两个 commit ，但没有更多的相关信息。运行 <code>git log -g</code> 会输出 reflog 的正常日志，从而显示更多有用信息：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git log </span><span class="pun">-</span><span class="pln">g
    commit </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln">
    </span><span class="typ">Reflog</span><span class="pun">:</span><span class="pln"> HEAD@</span><span class="pun">{</span><span class="lit">0</span><span class="pun">}</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;)</span><span class="pln">
    </span><span class="typ">Reflog</span><span class="pln"> message</span><span class="pun">:</span><span class="pln"> updating HEAD
    </span><span class="typ">Author</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="typ">Date</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Fri</span><span class="pln"> </span><span class="typ">May</span><span class="pln"> </span><span class="lit">22</span><span class="pln"> </span><span class="lit">18</span><span class="pun">:</span><span class="lit">22</span><span class="pun">:</span><span class="lit">37</span><span class="pln"> </span><span class="lit">2009</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">

    third commit

    commit ab1afef80fac8e34258ff41fc1b867c702daa24b
    </span><span class="typ">Reflog</span><span class="pun">:</span><span class="pln"> HEAD@</span><span class="pun">{</span><span class="lit">1</span><span class="pun">}</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;)</span><span class="pln">
    </span><span class="typ">Reflog</span><span class="pln"> message</span><span class="pun">:</span><span class="pln"> updating HEAD
    </span><span class="typ">Author</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Scott</span><span class="pln"> </span><span class="typ">Chacon</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">schacon@gmail</span><span class="pun">.</span><span class="pln">com</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="typ">Date</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Fri</span><span class="pln"> </span><span class="typ">May</span><span class="pln"> </span><span class="lit">22</span><span class="pln"> </span><span class="lit">18</span><span class="pun">:</span><span class="lit">15</span><span class="pun">:</span><span class="lit">24</span><span class="pln"> </span><span class="lit">2009</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0700</span><span class="pln">

    modified repo a bit</span></code></pre>

<p>看起来弄丢了的 commit 是底下那个，这样在那个 commit 上创建一个新分支就能把它恢复过来。比方说，可以在那个 commit (ab1afef) 上创建一个名为 <code>recover-branch</code>
    的分支：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git branch recover</span><span class="pun">-</span><span class="pln">branch ab1afef
    $ git log </span><span class="pun">--</span><span class="pln">pretty</span><span class="pun">=</span><span class="pln">oneline recover</span><span class="pun">-</span><span class="pln">branch
    ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
    </span><span class="lit">484a59275031909e19aadb7c92262719cfcdf19a</span><span class="pln"> added repo</span><span class="pun">.</span><span class="pln">rb
    </span><span class="lit">1a410efbd13591db07496601ebc7a059dd55cfe9</span><span class="pln"> third commit
    cac0cab538b970a37ea1e769cbbde608743bc96d second commit
    fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span></code></pre>

<p>酷！这样有了一个跟原来 <code>master</code> 一样的 <code>recover-branch</code> 分支，最新的两个 commit 又找回来了。接着，假设引起 commit 丢失的原因并没有记录在
    reflog 中 ── 可以通过删除 <code>recover-branch</code> 和 reflog 来模拟这种情况。这样最新的两个 commit 不会被任何东西引用到：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git branch </span><span class="pun">-</span><span class="pln">D recover</span><span class="pun">-</span><span class="pln">branch
    $ rm </span><span class="pun">-</span><span class="typ">Rf</span><span class="pln"> </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">logs</span><span class="pun">/</span></code></pre>

<p>因为 reflog 数据是保存在 <code>.git/logs/</code> 目录下的，这样就没有 reflog 了。现在要怎样恢复 commit 呢？办法之一是使用 <code>git fsck</code>
    工具，该工具会检查仓库的数据完整性。如果指定 <code>--ful</code> 选项，该命令显示所有未被其他对象引用 (指向) 的所有对象：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git fsck </span><span class="pun">--</span><span class="pln">full
    dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
    dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
    dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
    dangling blob </span><span class="lit">7108f7ecb345ee9d0084193f147cdad4d2998293</span></code></pre>

<p>本例中，可以从 dangling commit 找到丢失了的 commit。用相同的方法就可以恢复它，即创建一个指向该 SHA 的分支。</p>

<h3>移除对象</h3>

<p>Git 有许多过人之处，不过有一个功能有时却会带来问题：<code>git clone</code> 会将包含每一个文件的所有历史版本的整个项目下载下来。如果项目包含的仅仅是源代码的话这并没有什么坏处，毕竟 Git
    可以非常高效地压缩此类数据。不过如果有人在某个时刻往项目中添加了一个非常大的文件，那们即便他在后来的提交中将此文件删掉了，所有的签出都会下载这个大文件。因为历史记录中引用了这个文件，它会一直存在着。</p>

<p>当你将 Subversion 或 Perforce 仓库转换导入至 Git 时这会成为一个很严重的问题。在此类系统中，(签出时)
    不会下载整个仓库历史，所以这种情形不大会有不良后果。如果你从其他系统导入了一个仓库，或是发觉一个仓库的尺寸远超出预计，可以用下面的方法找到并移除大 (尺寸) 对象。</p>

<p>警告：此方法会破坏提交历史。为了移除对一个大文件的引用，从最早包含该引用的 tree 对象开始之后的所有 commit 对象都会被重写。如果在刚导入一个仓库并在其他人在此基础上开始工作之前这么做，那没有什么问题 ──
    否则你不得不通知所有协作者 (贡献者) 去衍合你新修改的 commit 。</p>

<p>为了演示这点，往 test 仓库中加入一个大文件，然后在下次提交时将它删除，接着找到并将这个文件从仓库中永久删除。首先，加一个大文件进去：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ curl http</span><span class="pun">:</span><span class="com">//kernel.org/pub/software/scm/git/git-1.6.3.1.tar.bz2 &gt; git.tbz2</span><span class="pln">
    $ git add git</span><span class="pun">.</span><span class="pln">tbz2
    $ git commit </span><span class="pun">-</span><span class="pln">am </span><span class="str">'added git tarball'</span><span class="pln">
    </span><span class="pun">[</span><span class="pln">master </span><span class="lit">6df7640</span><span class="pun">]</span><span class="pln"> added git tarball
    </span><span class="lit">1</span><span class="pln"> files changed</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> insertions</span><span class="pun">(+),</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> deletions</span><span class="pun">(-)</span><span class="pln">
    create mode </span><span class="lit">100644</span><span class="pln"> git</span><span class="pun">.</span><span class="pln">tbz2</span></code></pre>

<p>喔，你并不想往项目中加进一个这么大的 tar 包。最后还是去掉它：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git rm git</span><span class="pun">.</span><span class="pln">tbz2
    rm </span><span class="str">'git.tbz2'</span><span class="pln">
    $ git commit </span><span class="pun">-</span><span class="pln">m </span><span class="str">'oops - removed large tarball'</span><span class="pln">
    </span><span class="pun">[</span><span class="pln">master da3f30d</span><span class="pun">]</span><span class="pln"> oops </span><span class="pun">-</span><span class="pln"> removed large tarball
    </span><span class="lit">1</span><span class="pln"> files changed</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> insertions</span><span class="pun">(+),</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> deletions</span><span class="pun">(-)</span><span class="pln">
    </span><span class="kwd">delete</span><span class="pln"> mode </span><span class="lit">100644</span><span class="pln"> git</span><span class="pun">.</span><span class="pln">tbz2</span></code></pre>

<p>对仓库进行 <code>gc</code> 操作，并查看占用了空间：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git gc
    </span><span class="typ">Counting</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">21</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Delta</span><span class="pln"> compression </span><span class="kwd">using</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> threads</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Compressing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">16</span><span class="pun">/</span><span class="lit">16</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Writing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">21</span><span class="pun">/</span><span class="lit">21</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Total</span><span class="pln"> </span><span class="lit">21</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">3</span><span class="pun">),</span><span class="pln"> reused </span><span class="lit">15</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">1</span><span class="pun">)</span></code></pre>

<p>可以运行 <code>count-objects</code> 以查看使用了多少空间：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git count</span><span class="pun">-</span><span class="pln">objects </span><span class="pun">-</span><span class="pln">v
    count</span><span class="pun">:</span><span class="pln"> </span><span class="lit">4</span><span class="pln">
    size</span><span class="pun">:</span><span class="pln"> </span><span class="lit">16</span><span class="pln">
    </span><span class="kwd">in</span><span class="pun">-</span><span class="pln">pack</span><span class="pun">:</span><span class="pln"> </span><span class="lit">21</span><span class="pln">
    packs</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
    size</span><span class="pun">-</span><span class="pln">pack</span><span class="pun">:</span><span class="pln"> </span><span class="lit">2016</span><span class="pln">
    prune</span><span class="pun">-</span><span class="pln">packable</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
    garbage</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span></code></pre>

<p><code>size-pack</code> 是以千字节为单位表示的 packfiles 的大小，因此已经使用了 2MB 。而在这次提交之前仅用了 2K 左右 ──
    显然在这次提交时删除文件并没有真正将其从历史记录中删除。每当有人复制这个仓库去取得这个小项目时，都不得不复制所有 2MB 数据，而这仅仅因为你曾经不小心加了个大文件。当我们来解决这个问题。</p>

<p>首先要找出这个文件。在本例中，你知道是哪个文件。假设你并不知道这一点，要如何找出哪个 (些) 文件占用了这么多的空间？如果运行 <code>git gc</code>，所有对象会存入一个 packfile 文件；运行另一个底层命令
    <code>git verify-pack</code> 以识别出大对象，对输出的第三列信息即文件大小进行排序，还可以将输出定向到 <code>tail</code> 命令，因为你只关心排在最后的那几个最大的文件：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git verify</span><span class="pun">-</span><span class="pln">pack </span><span class="pun">-</span><span class="pln">v </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">objects</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">/</span><span class="pln">pack</span><span class="pun">-</span><span class="lit">3f8c0.</span><span class="pun">..</span><span class="pln">bb</span><span class="pun">.</span><span class="pln">idx </span><span class="pun">|</span><span class="pln"> sort </span><span class="pun">-</span><span class="pln">k </span><span class="lit">3</span><span class="pln"> </span><span class="pun">-</span><span class="pln">n </span><span class="pun">|</span><span class="pln"> tail </span><span class="pun">-</span><span class="lit">3</span><span class="pln">
    e3f094f522629ae358806b17daf78246c27c007b blob </span><span class="lit">1486</span><span class="pln"> </span><span class="lit">734</span><span class="pln"> </span><span class="lit">4667</span><span class="pln">
    </span><span class="lit">05408d195263d853f09dca71d55116663690c27c</span><span class="pln"> blob </span><span class="lit">12908</span><span class="pln"> </span><span class="lit">3478</span><span class="pln"> </span><span class="lit">1189</span><span class="pln">
    </span><span class="lit">7a9eb2fba2b1811321254ac360970fc169ba2330</span><span class="pln"> blob </span><span class="lit">2056716</span><span class="pln"> </span><span class="lit">2056872</span><span class="pln"> </span><span class="lit">5401</span></code></pre>

<p>最底下那个就是那个大文件：2MB 。要查看这到底是哪个文件，可以使用第 7 章中已经简单使用过的 <code>rev-list</code> 命令。若给 <code>rev-list</code> 命令传入 <code>--objects</code>
    选项，它会列出所有 commit SHA 值，blob SHA 值及相应的文件路径。可以这样查看 blob 的文件名：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git rev</span><span class="pun">-</span><span class="pln">list </span><span class="pun">--</span><span class="pln">objects </span><span class="pun">--</span><span class="pln">all </span><span class="pun">|</span><span class="pln"> grep </span><span class="lit">7a9eb2fb</span><span class="pln">
    </span><span class="lit">7a9eb2fba2b1811321254ac360970fc169ba2330</span><span class="pln"> git</span><span class="pun">.</span><span class="pln">tbz2</span></code></pre>

<p>接下来要将该文件从历史记录的所有 tree 中移除。很容易找出哪些 commit 修改了这个文件：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git log </span><span class="pun">--</span><span class="pln">pretty</span><span class="pun">=</span><span class="pln">oneline </span><span class="pun">--</span><span class="pln">branches </span><span class="pun">--</span><span class="pln"> git</span><span class="pun">.</span><span class="pln">tbz2
    da3f30d019005479c99eb4c3406225613985a1db oops </span><span class="pun">-</span><span class="pln"> removed large tarball
    </span><span class="lit">6df764092f3e7c8f5f94cbe08ee5cf42e92a0289</span><span class="pln"> added git tarball</span></code></pre>

<p>必须重写从 <code>6df76</code> 开始的所有 commit 才能将文件从 Git 历史中完全移除。这么做需要用到第 6 章中用过的 <code>filter-branch</code> 命令：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git filter</span><span class="pun">-</span><span class="pln">branch </span><span class="pun">--</span><span class="pln">index</span><span class="pun">-</span><span class="pln">filter \
    </span><span class="str">'git rm --cached --ignore-unmatch git.tbz2'</span><span class="pln"> </span><span class="pun">--</span><span class="pln"> </span><span class="lit">6df7640</span><span class="pun">^..</span><span class="pln">
    </span><span class="typ">Rewrite</span><span class="pln"> </span><span class="lit">6df764092f3e7c8f5f94cbe08ee5cf42e92a0289</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">/</span><span class="lit">2</span><span class="pun">)</span><span class="pln">rm </span><span class="str">'git.tbz2'</span><span class="pln">
    </span><span class="typ">Rewrite</span><span class="pln"> da3f30d019005479c99eb4c3406225613985a1db </span><span class="pun">(</span><span class="lit">2</span><span class="pun">/</span><span class="lit">2</span><span class="pun">)</span><span class="pln">
    </span><span class="typ">Ref</span><span class="pln"> </span><span class="str">'refs/heads/master'</span><span class="pln"> was rewritten</span></code></pre>

<p><code>--index-filter</code> 选项类似于第 6 章中使用的 <code>--tree-filter</code> 选项，但这里不是传入一个命令去修改磁盘上签出的文件，而是修改暂存区域或索引。不能用
    <code>rm file</code> 命令来删除一个特定文件，而是必须用 <code>git rm --cached</code> 来删除它 ── 即从索引而不是磁盘删除它。这样做是出于速度考虑 ── 由于 Git 在运行你的
    filter 之前无需将所有版本签出到磁盘上，这个操作会快得多。也可以用 <code>--tree-filter</code> 来完成相同的操作。<code>git rm</code> 的 <code>--ignore-unmatch</code>
    选项指定当你试图删除的内容并不存在时不显示错误。最后，因为你清楚问题是从哪个 commit 开始的，使用 <code>filter-branch</code> 重写自 <code>6df7640</code> 这个 commit
    开始的所有历史记录。不这么做的话会重写所有历史记录，花费不必要的更多时间。</p>

<p>现在历史记录中已经不包含对那个文件的引用了。不过 reflog 以及运行 <code>filter-branch</code> 时 Git 往 <code>.git/refs/original</code> 添加的一些 refs
    中仍有对它的引用，因此需要将这些引用删除并对仓库进行 repack 操作。在进行 repack 前需要将所有对这些 commits 的引用去除：</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ rm </span><span class="pun">-</span><span class="typ">Rf</span><span class="pln"> </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">refs</span><span class="pun">/</span><span class="pln">original
    $ rm </span><span class="pun">-</span><span class="typ">Rf</span><span class="pln"> </span><span class="pun">.</span><span class="pln">git</span><span class="pun">/</span><span class="pln">logs</span><span class="pun">/</span><span class="pln">
    $ git gc
    </span><span class="typ">Counting</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">19</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Delta</span><span class="pln"> compression </span><span class="kwd">using</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> threads</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Compressing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">14</span><span class="pun">/</span><span class="lit">14</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Writing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">19</span><span class="pun">/</span><span class="lit">19</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
    </span><span class="typ">Total</span><span class="pln"> </span><span class="lit">19</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">3</span><span class="pun">),</span><span class="pln"> reused </span><span class="lit">16</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">1</span><span class="pun">)</span></code></pre>

<p>看一下节省了多少空间。</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">$ git count</span><span class="pun">-</span><span class="pln">objects </span><span class="pun">-</span><span class="pln">v
    count</span><span class="pun">:</span><span class="pln"> </span><span class="lit">8</span><span class="pln">
    size</span><span class="pun">:</span><span class="pln"> </span><span class="lit">2040</span><span class="pln">
    </span><span class="kwd">in</span><span class="pun">-</span><span class="pln">pack</span><span class="pun">:</span><span class="pln"> </span><span class="lit">19</span><span class="pln">
    packs</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
    size</span><span class="pun">-</span><span class="pln">pack</span><span class="pun">:</span><span class="pln"> </span><span class="lit">7</span><span class="pln">
    prune</span><span class="pun">-</span><span class="pln">packable</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
    garbage</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span></code></pre>

<p>repack 后仓库的大小减小到了 7K ，远小于之前的 2MB 。从 size
    值可以看出大文件对象还在松散对象中，其实并没有消失，不过这没有关系，重要的是在再进行推送或复制，这个对象不会再传送出去。如果真的要完全把这个对象删除，可以运行 <code>git prune --expire</code> 命令。
</p>

<h2 id="9.8-总结"><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.8-%E6%80%BB%E7%BB%93">9.8 总结</a></h2>

<p>现在你应该对 Git 可以作什么相当了解了，并且在一定程度上也知道了 Git 是如何实现的。本章覆盖了许多 plumbing 命令 ── 这些命令比较底层，且比你在本书其他部分学到的 porcelain 命令要来得简单。从底层了解
    Git 的工作原理可以帮助你更好地理解为何 Git 实现了目前的这些功能，也使你能够针对你的工作流写出自己的工具和脚本。</p>

<p>Git 作为一套 content-addressable 的文件系统，是一个非常强大的工具，而不仅仅只是一个 VCS 供人使用。希望借助于你新学到的 Git 内部原理的知识，你可以实现自己的有趣的应用，并以更高级便利的方式使用
    Git。</p>

<p class="bottom-nav"><a class="prev" href="http://git.oschina.net/progit/8-Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F.html">上一节</a><a href="http://git.oschina.net/progit/index.html">首页（目录）</a> | <a href="http://git.oschina.net/">返回 码云</a></p>


<div style="position: static; width: 0px; height: 0px; border: none; padding: 0px; margin: 0px;"><div id="trans-tooltip"><div id="tip-left-top" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-left-top.png&quot;);"></div><div id="tip-top" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-top.png&quot;) repeat-x;"></div><div id="tip-right-top" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-right-top.png&quot;);"></div><div id="tip-right" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-right.png&quot;) repeat-y;"></div><div id="tip-right-bottom" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-right-bottom.png&quot;);"></div><div id="tip-bottom" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-bottom.png&quot;) repeat-x;"></div><div id="tip-left-bottom" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-left-bottom.png&quot;);"></div><div id="tip-left" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-left.png&quot;);"></div><div id="trans-content"></div></div><div id="tip-arrow-bottom" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-arrow-bottom.png&quot;);"></div><div id="tip-arrow-top" style="background: url(&quot;chrome-extension://ikkbfngojljohpekonpldkamedehakni/imgs/map/tip-arrow-top.png&quot;);"></div></div></body></html>